<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Top-Down Field + Paradigm Deck + Combat (Single File)</title>

<style>
  :root{
    --bg:#0b0e14;
    --panel1:#0f1628;
    --panel2:#070a14;
    --ink:#e6ecff;
    --muted:#9fb4ff;
    --line:rgba(120,160,255,0.18);
    --shadow:rgba(0,0,0,0.65);
  }

  html, body {
    height: 100%;
    margin: 0;
    background: var(--bg);
    overflow: hidden;
    touch-action: none;
    color: var(--ink);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
  }

  /* ===== FIELD ===== */
  #wrap {
    position: fixed;
    inset: 0;
    display: grid;
    place-items: center;
  }

  canvas {
    width: 100vw;
    height: 100vh;
    display: block;
  }

  .hint {
    position: fixed;
    top: 10px;
    left: 10px;
    font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial;
    color: rgba(255,255,255,.75);
    background: rgba(0,0,0,.35);
    padding: 8px 10px;
    border-radius: 12px;
    user-select: none;
    pointer-events: none;
    z-index: 2;
  }

  /* ===== FIELD MENU BUTTON ===== */
  #fieldMenuBtn{
    position: fixed;
    top: 10px;
    right: 10px;
    width: 44px;
    height: 44px;
    border-radius: 14px;
    display: grid;
    place-items: center;
    background: linear-gradient(180deg, #141c33, #0b1020);
    box-shadow:
      inset 0 0 0 1px rgba(120,160,255,0.2),
      0 8px 24px rgba(0,0,0,0.6);
    color: #cfe0ff;
    font-size: 18px;
    cursor: pointer;
    z-index: 3;
    user-select: none;
  }
  #fieldMenuBtn:active{ transform: scale(0.98); }

  /* ===== MENU OVERLAYS (FIELD) ===== */
  .menu{
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.55);
    backdrop-filter: blur(6px);
    display: none;
    z-index: 20;
  }

  .menuCard{
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: min(520px, calc(100vw - 22px));
    max-height: calc(100vh - 22px);
    overflow: auto;
    background: linear-gradient(180deg, var(--panel1), var(--panel2));
    border-radius: 18px;
    box-shadow:
      inset 0 0 0 1px var(--line),
      0 18px 48px var(--shadow);
    padding: 14px;
  }

  .menuTitle{
    font-weight: 800;
    letter-spacing: 0.3px;
    font-size: 14px;
    margin: 2px 0 10px;
    color: #cfe0ff;
  }

  .menuRow{
    display:flex;
    gap: 10px;
    flex-wrap: wrap;
  }

  .menu button{
    width: 100%;
    padding: 10px 12px;
    font-size: 12px;
    letter-spacing: 0.6px;
    text-transform: uppercase;
    background: linear-gradient(180deg, #141c33, #0b1020);
    color: #cfe0ff;
    border: none;
    border-radius: 12px;
    box-shadow:
      inset 0 0 0 1px rgba(120,160,255,0.2),
      0 2px 10px rgba(0,0,0,0.55);
    cursor: pointer;
  }
  .menu button:hover{ background: linear-gradient(180deg, #1b2550, #0f1633); }

  /* Paradigm deck cards */
  .pCard{
    border-radius: 16px;
    padding: 12px;
    margin: 10px 0;
    box-shadow:
      inset 0 0 0 1px rgba(120,160,255,0.14),
      0 12px 24px rgba(0,0,0,0.5);
    background: linear-gradient(180deg, rgba(14,18,34,0.85), rgba(7,9,17,0.85));
  }

  .pTop{
    display:flex;
    gap: 10px;
    align-items: center;
    margin-bottom: 10px;
  }

  .pName{
    width: 100%;
    padding: 10px 10px;
    border-radius: 12px;
    border: 1px solid rgba(120,160,255,0.18);
    background: rgba(0,0,0,0.25);
    color: #e6ecff;
    font-weight: 650;
    outline: none;
  }

  .pBadge{
    font-size: 11px;
    color: #9fb4ff;
    padding: 6px 10px;
    border-radius: 999px;
    border: 1px solid rgba(120,160,255,0.18);
    background: rgba(0,0,0,0.25);
    white-space: nowrap;
  }

  .pRoles{
    display:grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
  }

  .pRoles select{
    width: 100%;
    padding: 10px 10px;
    border-radius: 12px;
    border: 1px solid rgba(120,160,255,0.18);
    background: rgba(0,0,0,0.25);
    color: #e6ecff;
    outline: none;
  }

  .pActions{
    display:flex;
    gap: 10px;
    margin-top: 10px;
  }

  .pActions button{ width: 100%; }

  .subHint{
    margin-top: 10px;
    color: rgba(230,236,255,0.7);
    font-size: 12px;
  }

  /* ===== COMBAT SCENE ===== */
  #combatScene {
    position: fixed;
    inset: 0;
    display: none;
    z-index: 12;
    background: radial-gradient(circle at top, #0b0f1a, #000);
  }

  #combatScene #game {
    max-width: 520px;
    width: 100%;
    padding: 12px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    gap: 14px;
    margin: 0 auto;
  }

  #combatScene .unit {
    background: linear-gradient(180deg, #0f1628, #070a14);
    border-radius: 14px;
    padding: 10px;
    box-shadow:
      inset 0 0 0 1px rgba(120,160,255,0.15),
      0 8px 24px rgba(0,0,0,0.6);
  }

  #combatScene .label {
    font-size: 12px;
    letter-spacing: 0.5px;
    color: #9fb4ff;
    margin-bottom: 3px;
  }

  #combatScene .bar {
    height: 10px;
    background: #1a1f33;
    border-radius: 999px;
    overflow: hidden;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.8);
    margin-bottom: 6px;
  }

  #combatScene .bar > div {
    height: 100%;
    width: 0%;
    border-radius: 999px;
    transition: width 0.25s linear;
  }

  /* HP */
  #combatScene .bar.hp > div {
    background: linear-gradient(90deg, #2cff6a, #6dff9c);
    box-shadow: 0 0 6px rgba(60,255,140,0.7);
  }

  /* ATB */
  #combatScene .bar.atb > div {
    background: linear-gradient(90deg, #3aa0ff, #7fd1ff);
    box-shadow: 0 0 6px rgba(80,160,255,0.8);
  }

  #combatScene .unit.enemy {
    border: 1px solid rgba(255,120,120,0.25);
  }
  #combatScene .unit.enemy .bar.hp > div {
    background: linear-gradient(90deg, #ff4a4a, #ff9a9a);
    box-shadow: 0 0 8px rgba(255,80,80,0.9);
  }

  #combatScene #log {
    background: linear-gradient(180deg, #060912, #02040a);
    border-radius: 14px;
    padding: 10px;
    box-shadow:
      inset 0 0 0 1px rgba(120,160,255,0.15),
      0 8px 24px rgba(0,0,0,0.6);
    max-height: 170px;
    overflow-y: auto;
    font-size: 13px;
  }

  #combatScene #log div { color: #9aa4cc; }
  #combatScene #log div:last-child { color: #ffffff; }

  /* Paradigm Shift HUD */
  #combatHud{
    display:flex;
    gap: 8px;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 6px;
  }

  #combatHud .hudName{
    font-weight: 800;
    font-size: 12px;
    letter-spacing: 0.7px;
    text-transform: uppercase;
    color: #cfe0ff;
    opacity: 0.95;
  }

  #combatHud .hudRoles{
    font-size: 12px;
    color: rgba(230,236,255,0.75);
  }

  .hudBtns{
    display:flex;
    gap: 8px;
  }

  .hudBtns button{
    padding: 10px 12px;
    border-radius: 14px;
    border: none;
    background: linear-gradient(180deg, #141c33, #0b1020);
    color: #cfe0ff;
    box-shadow:
      inset 0 0 0 1px rgba(120,160,255,0.2),
      0 2px 10px rgba(0,0,0,0.6);
    cursor: pointer;
    font-size: 12px;
    letter-spacing: 0.7px;
    text-transform: uppercase;
    user-select: none;
  }
  .hudBtns button:active{ transform: scale(0.98); }

  /* Shift flash */
  #shiftFlash{
    position: fixed;
    inset: 0;
    pointer-events: none;
    opacity: 0;
    z-index: 50;
    background: radial-gradient(circle at center, rgba(120,160,255,0.25), rgba(0,0,0,0));
    transition: opacity 160ms ease;
  }
  #shiftFlash.on{ opacity: 1; }
</style>
</head>

<body>

<div class="hint">Move: Joystick (left side) or WASD / Arrows · Menu: ☰ · In combat: Q/E paradigm shift</div>
<div id="fieldMenuBtn" title="Menu">☰</div>

<!-- FIELD -->
<div id="wrap">
  <canvas id="c"></canvas>
</div>

<!-- FIELD MENU -->
<div id="fieldMenu" class="menu">
  <div class="menuCard">
    <div class="menuTitle">Field Menu</div>
    <div class="menuRow">
      <button id="openParadigms">Paradigms</button>
      <button id="closeMenu">Close</button>
    </div>
    <div class="subHint">Tip: Set your paradigm deck here, then shift instantly in combat.</div>
  </div>
</div>

<!-- PARADIGM MENU -->
<div id="paradigmMenu" class="menu">
  <div class="menuCard">
    <div class="menuTitle">Paradigm Deck</div>
    <div id="paradigmList"></div>
    <div class="menuRow">
      <button id="addParadigm">Add Paradigm</button>
      <button id="closeParadigms">Back</button>
    </div>
    <div class="subHint">Paradigms determine party roles. Your active paradigm is the one combat starts with.</div>
  </div>
</div>

<!-- COMBAT -->
<div id="combatScene">
  <div id="shiftFlash"></div>

  <div id="game">

    <div id="combatHud" class="unit">
      <div>
        <div class="hudName" id="hudParadigmName">Paradigm</div>
        <div class="hudRoles" id="hudParadigmRoles">Roles</div>
      </div>
      <div class="hudBtns">
        <button id="shiftPrev">◀</button>
        <button id="shiftNext">▶</button>
        <button id="escapeCombat">Run</button>
      </div>
    </div>

    <!-- Enemy -->
    <div class="unit enemy">
      <div class="label">Enemy HP</div>
      <div class="bar hp"><div id="enemy-hp"></div></div>
      <div class="label">Enemy ATB</div>
      <div class="bar atb"><div id="enemy-atb"></div></div>
    </div>

    <!-- Players -->
    <div id="players"></div>

    <div id="log"></div>
  </div>
</div>

<script>
/* =========================================================
   CORE STATE
========================================================= */
let gameState = "field"; // "field" | "combat" | "menu"

/* =========================================================
   CANVAS SETUP
========================================================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize() {
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  canvas.width = Math.floor(innerWidth * dpr);
  canvas.height = Math.floor(innerHeight * dpr);
  canvas.style.width = innerWidth + "px";
  canvas.style.height = innerHeight + "px";
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
addEventListener("resize", resize);
resize();

/* =========================================================
   PLAYER (FIELD)
========================================================= */
const player = {
  x: innerWidth * 0.5,
  y: innerHeight * 0.5,
  r: 16,
  speed: 240,
  vx: 0,
  vy: 0
};

/* =========================================================
   INPUT
========================================================= */
const keys = new Set();
addEventListener("keydown", e => keys.add(e.key.toLowerCase()));
addEventListener("keyup", e => keys.delete(e.key.toLowerCase()));

function keyboardAxis() {
  let x = 0, y = 0;
  if (keys.has("arrowleft") || keys.has("a")) x -= 1;
  if (keys.has("arrowright") || keys.has("d")) x += 1;
  if (keys.has("arrowup") || keys.has("w")) y -= 1;
  if (keys.has("arrowdown") || keys.has("s")) y += 1;
  const len = Math.hypot(x, y);
  if (len > 0) { x /= len; y /= len; }
  return { x, y };
}

/* =========================================================
   VIRTUAL JOYSTICK
========================================================= */
const joy = {
  active: false,
  id: null,
  baseX: 0, baseY: 0,
  knobX: 0, knobY: 0,
  max: 52,
  dead: 0.10,
  axisX: 0, axisY: 0
};

function setJoy(px, py) {
  const dx = px - joy.baseX;
  const dy = py - joy.baseY;
  const dist = Math.hypot(dx, dy);
  const clamped = Math.min(dist, joy.max);
  const nx = dist ? dx / dist : 0;
  const ny = dist ? dy / dist : 0;

  joy.knobX = joy.baseX + nx * clamped;
  joy.knobY = joy.baseY + ny * clamped;

  let ax = (nx * clamped) / joy.max;
  let ay = (ny * clamped) / joy.max;
  const alen = Math.hypot(ax, ay);

  if (alen < joy.dead) {
    ax = ay = 0;
  } else {
    const t = (alen - joy.dead) / (1 - joy.dead);
    ax = (ax / alen) * t;
    ay = (ay / alen) * t;
  }

  joy.axisX = ax;
  joy.axisY = ay;
}

canvas.addEventListener("pointerdown", e => {
  if (gameState !== "field") return;
  canvas.setPointerCapture(e.pointerId);
  if (!joy.active) {
    joy.active = true;
    joy.id = e.pointerId;
    joy.baseX = e.clientX;
    joy.baseY = e.clientY;
    joy.knobX = e.clientX;
    joy.knobY = e.clientY;
  }
});

canvas.addEventListener("pointermove", e => {
  if (gameState !== "field") return;
  if (joy.active && e.pointerId === joy.id) {
    setJoy(e.clientX, e.clientY);
  }
});

function endJoy(e) {
  if (e.pointerId === joy.id) {
    joy.active = false;
    joy.id = null;
    joy.axisX = joy.axisY = 0;
  }
}
canvas.addEventListener("pointerup", endJoy);
canvas.addEventListener("pointercancel", endJoy);
canvas.addEventListener("pointerout", endJoy);

/* =========================================================
   PARADIGMS (FIELD MENU SYSTEM)
========================================================= */
const ROLE_LIST = ["Commando", "Ravager", "Medic"];

let paradigms = [
  { name: "Relentless Assault", roles: ["Commando", "Ravager", "Ravager"] },
  { name: "Delta Attack",       roles: ["Commando", "Commando", "Ravager"] },
  { name: "Solidarity",         roles: ["Commando", "Medic", "Medic"] },
  { name: "Tri-Disaster",       roles: ["Ravager", "Ravager", "Ravager"] },
];

let activeParadigmIndex = 0;

function paradigmText(p) {
  return p.roles.map(r => r.slice(0,3).toUpperCase()).join(" / ");
}

function flashShift() {
  const fx = document.getElementById("shiftFlash");
  fx.classList.add("on");
  setTimeout(() => fx.classList.remove("on"), 160);
}

function updateCombatHud() {
  const p = paradigms[activeParadigmIndex];
  document.getElementById("hudParadigmName").textContent = `Paradigm: ${p.name}`;
  document.getElementById("hudParadigmRoles").textContent = `Roles: ${paradigmText(p)}  (Q/E)`;
}

function applyParadigm(index, { silent = false } = {}) {
  if (!paradigms.length) return;
  activeParadigmIndex = (index + paradigms.length) % paradigms.length;
  const p = paradigms[activeParadigmIndex];

  players.forEach((plr, i) => {
    plr.role = p.roles[i] || "Commando";
  });

  updateCombatHud();
  if (!silent && typeof logMsg === "function") {
    logMsg(`Paradigm → ${p.name} (${paradigmText(p)})`);
    flashShift();
  }
}

function renderParadigmMenu() {
  const list = document.getElementById("paradigmList");
  list.innerHTML = "";

  paradigms.forEach((p, idx) => {
    const card = document.createElement("div");
    card.className = "pCard";

    const isActive = idx === activeParadigmIndex;

    card.innerHTML = `
      <div class="pTop">
        <input class="pName" value="${p.name.replaceAll('"','&quot;')}" data-name="${idx}" />
        <div class="pBadge">${isActive ? "ACTIVE" : ""}</div>
      </div>
      <div class="pRoles">
        ${[0,1,2].map(i => `
          <select data-idx="${idx}" data-slot="${i}">
            ${ROLE_LIST.map(r => `<option value="${r}" ${p.roles[i]===r?"selected":""}>${r}</option>`).join("")}
          </select>
        `).join("")}
      </div>
      <div class="pActions">
        <button class="pSet" data-set="${idx}">${isActive ? "Active" : "Set Active"}</button>
        <button class="pDel" data-del="${idx}">Delete</button>
      </div>
    `;

    list.appendChild(card);
  });

  list.querySelectorAll(".pName").forEach(inp => {
    inp.addEventListener("input", () => {
      const idx = +inp.dataset.name;
      paradigms[idx].name = inp.value;
      if (idx === activeParadigmIndex) updateCombatHud();
    });
  });

  list.querySelectorAll("select").forEach(sel => {
    sel.addEventListener("change", () => {
      const pIdx = +sel.dataset.idx;
      const slot = +sel.dataset.slot;
      paradigms[pIdx].roles[slot] = sel.value;
      if (pIdx === activeParadigmIndex) {
        applyParadigm(activeParadigmIndex, { silent: true });
      }
      renderParadigmMenu();
    });
  });

  list.querySelectorAll(".pSet").forEach(btn => {
    btn.addEventListener("click", () => {
      activeParadigmIndex = +btn.dataset.set;
      applyParadigm(activeParadigmIndex, { silent: true });
      renderParadigmMenu();
    });
  });

  list.querySelectorAll(".pDel").forEach(btn => {
    btn.addEventListener("click", () => {
      const idx = +btn.dataset.del;
      paradigms.splice(idx, 1);
      if (activeParadigmIndex >= paradigms.length) activeParadigmIndex = Math.max(0, paradigms.length - 1);
      applyParadigm(activeParadigmIndex, { silent: true });
      renderParadigmMenu();
    });
  });
}

/* =========================================================
   MENU OPEN/CLOSE
========================================================= */
const fieldMenuBtn = document.getElementById("fieldMenuBtn");
const fieldMenu = document.getElementById("fieldMenu");
const paradigmMenu = document.getElementById("paradigmMenu");

function openFieldMenu() {
  if (gameState !== "field") return;
  gameState = "menu";
  fieldMenu.style.display = "block";
}
function closeFieldMenu() {
  if (gameState !== "menu") return;
  fieldMenu.style.display = "none";
  paradigmMenu.style.display = "none";
  gameState = "field";
  last = performance.now();
  requestAnimationFrame(tick);
}

function openParadigms() {
  paradigmMenu.style.display = "block";
  fieldMenu.style.display = "none";
  renderParadigmMenu();
}
function closeParadigms() {
  paradigmMenu.style.display = "none";
  fieldMenu.style.display = "block";
}

fieldMenuBtn.addEventListener("click", () => {
  if (gameState === "field") openFieldMenu();
  else if (gameState === "menu") closeFieldMenu();
});

document.getElementById("openParadigms").addEventListener("click", openParadigms);
document.getElementById("closeMenu").addEventListener("click", closeFieldMenu);
document.getElementById("closeParadigms").addEventListener("click", closeParadigms);

document.getElementById("addParadigm").addEventListener("click", () => {
  paradigms.push({ name: `Paradigm ${paradigms.length+1}`, roles: ["Commando","Ravager","Medic"] });
  renderParadigmMenu();
});

/* =========================================================
   RANDOM ENCOUNTERS
========================================================= */
let encounterTimer = 0;

function tryEncounter(dt) {
  encounterTimer += dt;
  if (encounterTimer > 3) {
    encounterTimer = 0;
    if (Math.random() < 0.25) {
      startCombat();
    }
  }
}

/* =========================================================
   COMBAT SYSTEM (ATB 3v1 + PARADIGM SHIFT)
========================================================= */
const combatScene = document.getElementById("combatScene");
const logEl = document.getElementById("log");

const players = [
  { hp: 100, maxHp: 100, atb: 0, role: "Commando", atbRate: 1.0 },
  { hp: 100, maxHp: 100, atb: 0, role: "Ravager",  atbRate: 1.2 },
  { hp: 100, maxHp: 100, atb: 0, role: "Medic",   atbRate: 1.4 }
];

let enemy = {
  hp: 600,
  maxHp: 600,
  atb: 0
};

const speed = 1.6;
let battleOver = false;
let combatTimerId = null;

function logMsg(msg) {
  const div = document.createElement("div");
  div.textContent = msg;
  logEl.appendChild(div);
  logEl.scrollTop = logEl.scrollHeight;
}

function renderPlayers() {
  const container = document.getElementById("players");
  container.innerHTML = "";

  players.forEach((p, i) => {
    const unit = document.createElement("div");
    unit.className = "unit";
    unit.innerHTML = `
      <div class="label">Player ${i + 1} HP · ${p.role}</div>
      <div class="bar hp"><div id="p${i}-hp"></div></div>
      <div class="label">ATB</div>
      <div class="bar atb"><div id="p${i}-atb"></div></div>
    `;
    container.appendChild(unit);
  });
}

function updateBars() {
  players.forEach((p, i) => {
    const hpEl = document.getElementById(`p${i}-hp`);
    const atbEl = document.getElementById(`p${i}-atb`);
    if (hpEl) hpEl.style.width = (p.hp / p.maxHp * 100) + "%";
    if (atbEl) atbEl.style.width = Math.min(p.atb, 100) + "%";
  });

  document.getElementById("enemy-hp").style.width = (enemy.hp / enemy.maxHp * 100) + "%";
  document.getElementById("enemy-atb").style.width = Math.min(enemy.atb, 100) + "%";
}

function alivePlayers() {
  return players.filter(p => p.hp > 0);
}

function endBattle(resultText) {
  battleOver = true;
  logMsg(resultText);
  // short delay so last log reads nicely
  setTimeout(() => endCombat(), 900);
}

function roleAction(p, i) {
  if (p.role === "Commando") {
    enemy.hp = Math.max(0, enemy.hp - 25);
    logMsg(`P${i + 1} attacks (25)`);
  }
  if (p.role === "Ravager") {
    enemy.hp = Math.max(0, enemy.hp - 15);
    logMsg(`P${i + 1} rapid hits (15)`);
  }
  if (p.role === "Medic") {
    // heal lowest HP living ally (including self)
    const targets = alivePlayers().sort((a,b) => (a.hp/a.maxHp) - (b.hp/b.maxHp));
    if (targets.length) {
      const t = targets[0];
      t.hp = Math.min(t.maxHp, t.hp + 30);
      logMsg(`P${i + 1} heals (30)`);
    }
  }
}

function combatLoop() {
  if (battleOver || gameState !== "combat") return;

  players.forEach((p, i) => {
    if (p.hp <= 0) return;

    p.atb += p.atbRate * speed;
    if (p.atb >= 100) {
      roleAction(p, i);
      p.atb = 0;
    }
  });

  enemy.atb += 2 * speed;
  if (enemy.atb >= 100) {
    const targets = alivePlayers();
    if (targets.length > 0) {
      const t = targets[Math.floor(Math.random() * targets.length)];
      t.hp = Math.max(0, t.hp - 20);
      logMsg("Enemy attacks (20)");
    }
    enemy.atb = 0;
  }

  updateBars();

  if (enemy.hp <= 0) {
    endBattle("Victory!");
    return;
  }
  if (alivePlayers().length === 0) {
    endBattle("Defeat...");
    return;
  }

  combatTimerId = setTimeout(combatLoop, 100);
}

function initCombat() {
  battleOver = false;
  if (combatTimerId) clearTimeout(combatTimerId);

  // reset combat UI + log
  logEl.innerHTML = "";

  // reset ATB
  players.forEach(p => p.atb = 0);

  // new enemy each battle (easy to swap later)
  enemy = { hp: 600, maxHp: 600, atb: 0 };

  // apply active paradigm (silent so it doesn't double-log on battle start)
  applyParadigm(activeParadigmIndex, { silent: true });

  renderPlayers();
  updateCombatHud();
  updateBars();

  logMsg(`Encounter! (Starting Paradigm: ${paradigms[activeParadigmIndex]?.name || "N/A"})`);
}

function startCombat() {
  gameState = "combat";
  combatScene.style.display = "block";
  initCombat();
  combatLoop();
}

function endCombat() {
  if (combatTimerId) clearTimeout(combatTimerId);
  combatTimerId = null;
  battleOver = true;

  combatScene.style.display = "none";
  gameState = "field";
  last = performance.now();
  requestAnimationFrame(tick);
}

/* =========================================================
   COMBAT CONTROLS: PARADIGM SHIFT
========================================================= */
function shiftPrev() {
  if (gameState !== "combat") return;
  applyParadigm(activeParadigmIndex - 1);
  renderPlayers();
}
function shiftNext() {
  if (gameState !== "combat") return;
  applyParadigm(activeParadigmIndex + 1);
  renderPlayers();
}

document.getElementById("shiftPrev").addEventListener("click", shiftPrev);
document.getElementById("shiftNext").addEventListener("click", shiftNext);
document.getElementById("escapeCombat").addEventListener("click", () => {
  if (gameState !== "combat") return;
  logMsg("You fled...");
  setTimeout(() => endCombat(), 400);
});

addEventListener("keydown", (e) => {
  const k = e.key.toLowerCase();

  if (gameState === "field") {
    if (k === "escape" || k === "m") openFieldMenu();
  }

  if (gameState === "menu") {
    if (k === "escape") closeFieldMenu();
  }

  if (gameState === "combat") {
    if (k === "q") shiftPrev();
    if (k === "e") shiftNext();
    if (k === "escape") {
      logMsg("You fled...");
      setTimeout(() => endCombat(), 400);
    }
  }
});

/* =========================================================
   GAME LOOP (FIELD)
========================================================= */
let last = performance.now();
function tick(now) {
  if (gameState !== "field") return;

  const dt = Math.min(0.05, (now - last) / 1000);
  last = now;

  const kb = keyboardAxis();
  let ax = kb.x, ay = kb.y;
  if (joy.axisX || joy.axisY) {
    ax = joy.axisX;
    ay = joy.axisY;
  }

  player.vx = ax * player.speed;
  player.vy = ay * player.speed;
  player.x += player.vx * dt;
  player.y += player.vy * dt;

  player.x = Math.max(player.r, Math.min(innerWidth - player.r, player.x));
  player.y = Math.max(player.r, Math.min(innerHeight - player.r, player.y));

  tryEncounter(dt);
  draw();
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* =========================================================
   RENDERING (FIELD)
========================================================= */
function drawGrid(spacing = 48) {
  ctx.globalAlpha = 0.18;
  ctx.strokeStyle = "#9bdcff";
  for (let x = 0; x <= innerWidth; x += spacing) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, innerHeight); ctx.stroke();
  }
  for (let y = 0; y <= innerHeight; y += spacing) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(innerWidth, y); ctx.stroke();
  }
  ctx.globalAlpha = 1;
}

function drawPlayer() {
  ctx.fillStyle = "#7CFF8A";
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
  ctx.fill();
}

function drawJoystick() {
  if (!joy.active) return;
  ctx.globalAlpha = 0.6;
  ctx.fillStyle = "#1b2433";
  ctx.beginPath();
  ctx.arc(joy.baseX, joy.baseY, joy.max, 0, Math.PI * 2);
  ctx.fill();

  ctx.globalAlpha = 0.9;
  ctx.fillStyle = "#9bdcff";
  ctx.beginPath();
  ctx.arc(joy.knobX, joy.knobY, joy.max * 0.45, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;
}

function draw() {
  ctx.clearRect(0, 0, innerWidth, innerHeight);
  ctx.fillStyle = "#0b0e14";
  ctx.fillRect(0, 0, innerWidth, innerHeight);
  drawGrid();
  drawPlayer();
  drawJoystick();
}

/* =========================================================
   INIT
========================================================= */
applyParadigm(activeParadigmIndex, { silent: true });
updateCombatHud();
</script>

</body>
</html>
