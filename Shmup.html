<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Mobile Shmup (Canvas)</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #07080c;
      overflow: hidden;
      touch-action: none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: #e9eefc;
    }
    #wrap { position: fixed; inset: 0; display: grid; place-items: center; }
    canvas { width: 100vw; height: 100vh; display: block; image-rendering: pixelated; }

    #hud {
      position: fixed;
      left: 12px;
      top: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
      font-weight: 700;
      letter-spacing: 0.3px;
      user-select: none;
      -webkit-user-select: none;
      pointer-events: none;
      z-index: 5;
    }
    .pill {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 999px;
      padding: 6px 10px;
      backdrop-filter: blur(6px);
    }

    #buttons {
      position: fixed;
      right: 12px;
      top: 10px;
      display: flex;
      gap: 10px;
      z-index: 6;
    }
    button {
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: #e9eefc;
      border-radius: 12px;
      padding: 8px 12px;
      font-weight: 700;
      letter-spacing: 0.2px;
      backdrop-filter: blur(6px);
      cursor: pointer;
    }
    button:active { transform: scale(0.98); }

    #overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: radial-gradient(ellipse at center, rgba(20,30,60,0.58), rgba(0,0,0,0.78));
      text-align: center;
      padding: 24px;
      z-index: 10;
    }
    #panel {
      max-width: 520px;
      width: min(520px, 92vw);
      background: rgba(255,255,255,0.07);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 20px;
      padding: 18px 18px 16px;
      box-shadow: 0 18px 50px rgba(0,0,0,0.45);
      backdrop-filter: blur(10px);
    }
    #panel h1 { margin: 0 0 8px; font-size: 22px; }
    #panel p { margin: 6px 0; opacity: 0.9; line-height: 1.35; }
    #panel .row { display: flex; gap: 10px; justify-content: center; margin-top: 14px; flex-wrap: wrap; }
    #panel .hint { font-size: 13px; opacity: 0.8; margin-top: 10px; }
    #panel kbd {
      border: 1px solid rgba(255,255,255,0.22);
      background: rgba(255,255,255,0.10);
      border-radius: 8px;
      padding: 2px 6px;
      font-weight: 800;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="c"></canvas>
  </div>

  <div id="hud">
    <div class="pill">Score: <span id="score">0</span></div>
    <div class="pill">Lives: <span id="lives">3</span></div>
  </div>

  <div id="buttons">
    <button id="pauseBtn" type="button">Pause</button>
    <button id="restartBtn" type="button">Restart</button>
  </div>

  <div id="overlay">
    <div id="panel">
      <h1>ðŸ“± Mobile Shmup</h1>
      <p><b>Touch:</b> drag anywhere to move. Tap/hold to shoot.</p>
      <p><b>Desktop:</b> <kbd>WASD</kbd>/<kbd>Arrow</kbd> to move, <kbd>Space</kbd> to shoot, <kbd>P</kbd> to pause.</p>
      <p class="hint">Stages now end with a boss. Clear it to see an arcade-style stage intro.</p>
      <div class="row">
        <button id="startBtn" type="button">Start</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Canvas + Resize =====
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  let W = 0, H = 0, DPR = 1;

  function resize() {
    DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  window.addEventListener("resize", resize, { passive: true });
  resize();

  // ===== UI =====
  const scoreEl = document.getElementById("score");
  const livesEl = document.getElementById("lives");
  const overlay = document.getElementById("overlay");
  const startBtn = document.getElementById("startBtn");
  const pauseBtn = document.getElementById("pauseBtn");
  const restartBtn = document.getElementById("restartBtn");

  // ===== Helpers =====
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const rand = (a, b) => a + Math.random() * (b - a);

  function circleHit(ax, ay, ar, bx, by, br) {
    const dx = ax - bx, dy = ay - by;
    return (dx*dx + dy*dy) <= (ar + br) * (ar + br);
  }

  // ===== Hard Caps =====
  const MAX_BULLETS = 320;
  const MAX_ENEMIES = 140;
  const MAX_STARS   = 160;
  const MAX_BOSS_BULLETS = 260;

  // ===== Game State =====
  let running = false;
  let paused = false;
  let gameOver = false;

  const keys = new Set();
  let shootHeld = false;

  let score = 0;
  let lives = 3;

  // ===== Stage System =====
  let stage = 1;
  let stageTimer = 0;
  const STAGE_LENGTH = 22; // seconds of normal play before boss

  // Arcade intro card
  let stageIntro = true;
  let introTimer = 0;
  const INTRO_DURATION = 2.8;

  // Boss state
  let inBossFight = false;
  let boss = null;

  // Difficulty knobs
  let enemyRate = 0.6;        // spawn multiplier
  let enemySpeedBase = 90;    // px/s
  let bulletSpeed = 720;      // px/s
  let fireCooldown = 0.13;    // seconds between shots

  function applyStageDifficulty(s) {
    if (s === 1) {
      enemyRate = 0.6;
      enemySpeedBase = 90;
      fireCooldown = 0.13;
    } else if (s === 2) {
      enemyRate = 0.75;
      enemySpeedBase = 105;
      fireCooldown = 0.12;
    } else if (s === 3) {
      enemyRate = 0.9;
      enemySpeedBase = 125;
      fireCooldown = 0.11;
    } else if (s === 4) {
      enemyRate = 1.05;
      enemySpeedBase = 145;
      fireCooldown = 0.10;
    } else {
      enemyRate = 1.05 + (s - 4) * 0.08;
      enemySpeedBase = 145 + (s - 4) * 10;
      fireCooldown = Math.max(0.075, 0.10 - (s - 4) * 0.004);
    }
  }

  // Entities
  const bullets = [];
  const enemies = [];
  const bossBullets = [];
  const stars = [];

  // ===== Player =====
  const player = {
    x: 0, y: 0,
    r: 14,
    speed: 420,
    invuln: 0,
    fireTimer: 0
  };

  function startStageIntro() {
    stageIntro = true;
    introTimer = INTRO_DURATION;
  }

  function reset() {
    score = 0;
    lives = 3;

    stage = 1;
    stageTimer = 0;
    applyStageDifficulty(stage);

    bullets.length = 0;
    enemies.length = 0;
    bossBullets.length = 0;
    stars.length = 0;

    inBossFight = false;
    boss = null;

    player.x = W * 0.5;
    player.y = H * 0.82;
    player.invuln = 1.0;
    player.fireTimer = 0;

    const starCount = Math.min(MAX_STARS, 140);
    for (let i = 0; i < starCount; i++) {
      stars.push({
        x: Math.random() * W,
        y: Math.random() * H,
        s: rand(0.6, 2.2),
        v: rand(30, 140)
      });
    }

    gameOver = false;
    startStageIntro();
    updateHud();
  }

  function updateHud() {
    scoreEl.textContent = score;
    livesEl.textContent = lives;
  }

  // ===== Spawning =====
  let spawnTimer = 0;

  function spawnEnemy() {
    if (enemies.length >= MAX_ENEMIES) return;

    // Tanks unlock at Stage 2
    let type = "drifter";
    if (stage >= 2 && Math.random() < 0.20) type = "tank";

    const r = type === "tank" ? 18 : 14;
    const hp = type === "tank" ? 4 : 1;

    enemies.push({
      x: rand(20, W - 20),
      y: -30,
      r,
      hp,
      type,
      vy: enemySpeedBase * (type === "tank" ? 0.75 : 1.0) + rand(-12, 30),
      vx: (type === "drifter" ? rand(-70, 70) : rand(-30, 30)),
      wob: rand(1.2, 2.2),
      t: rand(0, 10)
    });
  }

  function spawnBoss() {
    inBossFight = true;
    // Clear regular enemies to make the boss moment readable
    enemies.length = 0;
    spawnTimer = 0;

    const maxHp = 140 + stage * 35;
    boss = {
      x: W * 0.5,
      y: -160,
      r: 64,
      hp: maxHp,
      maxHp,
      vy: 120,
      t: 0,
      fireTimer: 0,
      fireCooldown: Math.max(0.55, 1.15 - stage * 0.07),
      phase: 0
    };
  }

  function bossFire() {
    if (!boss) return;
    if (bossBullets.length >= MAX_BOSS_BULLETS) return;

    // A gentle radial burst that scales a bit with stage
    const n = clamp(8 + Math.floor(stage * 0.7), 8, 14);
    const speed = 170 + stage * 10;

    for (let i = 0; i < n; i++) {
      if (bossBullets.length >= MAX_BOSS_BULLETS) break;
      const a = (i / n) * Math.PI * 2;
      bossBullets.push({
        x: boss.x,
        y: boss.y + 10,
        r: 4,
        vx: Math.cos(a) * speed,
        vy: Math.sin(a) * speed
      });
    }
  }

  // ===== Input (Touch) =====
  let touchActive = false;
  let touchId = null;
  let touchOffsetX = 0;
  let touchOffsetY = 0;

  canvas.addEventListener("pointerdown", (e) => {
    canvas.setPointerCapture(e.pointerId);
    touchActive = true;
    touchId = e.pointerId;
    shootHeld = true;

    touchOffsetX = player.x - e.clientX;
    touchOffsetY = player.y - e.clientY;
  });

  canvas.addEventListener("pointermove", (e) => {
    if (!touchActive || e.pointerId !== touchId) return;
    player.x = clamp(e.clientX + touchOffsetX, 20, W - 20);
    player.y = clamp(e.clientY + touchOffsetY, 20, H - 20);
  });

  function endPointer(e) {
    if (e.pointerId !== touchId) return;
    touchActive = false;
    touchId = null;
    shootHeld = false;
  }
  canvas.addEventListener("pointerup", endPointer);
  canvas.addEventListener("pointercancel", endPointer);
  canvas.addEventListener("pointerleave", endPointer);

  // ===== Input (Keyboard) =====
  window.addEventListener("keydown", (e) => {
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();
    keys.add(e.key.toLowerCase());
    if (e.key === " " || e.code === "Space") shootHeld = true;
    if (e.key.toLowerCase() === "p") togglePause();
  }, { passive: false });

  window.addEventListener("keyup", (e) => {
    keys.delete(e.key.toLowerCase());
    if (e.key === " " || e.code === "Space") shootHeld = false;
  }, { passive: true });

  // ===== Buttons =====
  startBtn.addEventListener("click", () => {
    overlay.style.display = "none";
    running = true;
    paused = false;
  });

  pauseBtn.addEventListener("click", () => togglePause());
  restartBtn.addEventListener("click", () => {
    reset();
    overlay.style.display = "none";
    running = true;
    paused = false;
  });

  function togglePause() {
    if (!running) return;
    paused = !paused;
    pauseBtn.textContent = paused ? "Resume" : "Pause";
  }

  // ===== Game Loop =====
  let last = performance.now();

  function tick(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    if (running && !paused) {
      update(dt);
      render(dt);
    } else {
      render(dt);
      if (paused) drawPaused();
    }

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // ===== Update =====
  function update(dt) {
    if (gameOver) return;

    // Freeze gameplay during stage intro card
    if (stageIntro) {
      introTimer -= dt;
      if (introTimer <= 0) stageIntro = false;
      return;
    }

    // Player movement (keyboard only; touch directly sets)
    let mx = 0, my = 0;
    if (keys.has("arrowleft") || keys.has("a")) mx -= 1;
    if (keys.has("arrowright") || keys.has("d")) mx += 1;
    if (keys.has("arrowup") || keys.has("w")) my -= 1;
    if (keys.has("arrowdown") || keys.has("s")) my += 1;

    if (!touchActive) {
      const len = Math.hypot(mx, my) || 1;
      mx /= len; my /= len;
      player.x = clamp(player.x + mx * player.speed * dt, 20, W - 20);
      player.y = clamp(player.y + my * player.speed * dt, 20, H - 20);
    }

    // Shooting (hold)
    player.fireTimer -= dt;
    if (shootHeld && player.fireTimer <= 0) {
      player.fireTimer = fireCooldown;
      fire();
    }

    // Stars
    for (let i = 0; i < stars.length; i++) {
      const st = stars[i];
      st.y += st.v * dt;
      if (st.y > H + 10) {
        st.y = -10;
        st.x = Math.random() * W;
        st.v = rand(30, 150) + stage * 4;
        st.s = rand(0.6, 2.2);
      }
    }

    // Stage timer: trigger boss instead of instant stage increment
    if (!inBossFight && !boss) {
      stageTimer += dt;
      if (stageTimer >= STAGE_LENGTH) {
        stageTimer = 0;
        spawnBoss();
      }
    }

    // Normal enemy spawns only when NOT in boss fight
    if (!inBossFight && !boss) {
      spawnTimer += dt;
      const spawnsPerSecond = Math.min(3.2, 1.2 + stage * 0.35);

      while (spawnTimer >= 1 / 60) {
        spawnTimer -= 1 / 60;
        if (enemies.length >= MAX_ENEMIES) break;
        const p = clamp((spawnsPerSecond / 60) * enemyRate, 0, 0.25);
        if (Math.random() < p) spawnEnemy();
      }
    }

    // Bullets (move + cleanup)
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.y -= b.v * dt;
      if (b.y < -30) bullets.splice(i, 1);
    }

    // Enemies (move + cleanup)
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      e.t += dt;
      e.y += e.vy * dt;
      e.x += (e.vx + Math.sin(e.t * e.wob) * 22) * dt;

      if (e.x < 16) { e.x = 16; e.vx = Math.abs(e.vx); }
      if (e.x > W - 16) { e.x = W - 16; e.vx = -Math.abs(e.vx); }

      if (e.y > H + 60) enemies.splice(i, 1);
    }

    // Boss update
    if (boss) {
      boss.t += dt;

      // entrance
      if (boss.y < 120) {
        boss.y += boss.vy * dt;
      } else {
        boss.phase = 1;
      }

      // simple drift pattern
      if (boss.phase === 1) {
        boss.x = W * 0.5 + Math.sin(boss.t * 1.1) * (W * 0.22);
      }

      // fire
      boss.fireTimer -= dt;
      if (boss.phase === 1 && boss.fireTimer <= 0) {
        boss.fireTimer = boss.fireCooldown;
        bossFire();
      }

      // bullets hit boss
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        if (circleHit(boss.x, boss.y, boss.r, b.x, b.y, b.r)) {
          bullets.splice(i, 1);
          boss.hp -= 1;
          score += 5;
        }
      }

      // defeat
      if (boss.hp <= 0) {
        score += 250 + stage * 50;
        boss = null;
        bossBullets.length = 0;
        bullets.length = 0;

        inBossFight = false;

        stage += 1;
        applyStageDifficulty(stage);
        startStageIntro();
      }
    }

    // Boss bullets (move + cleanup)
    for (let i = bossBullets.length - 1; i >= 0; i--) {
      const bb = bossBullets[i];
      bb.x += bb.vx * dt;
      bb.y += bb.vy * dt;

      // remove if far off screen
      if (bb.x < -80 || bb.x > W + 80 || bb.y < -80 || bb.y > H + 80) {
        bossBullets.splice(i, 1);
      }
    }

    // Collisions: bullets vs enemies
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      for (let j = bullets.length - 1; j >= 0; j--) {
        const b = bullets[j];
        if (circleHit(e.x, e.y, e.r, b.x, b.y, b.r)) {
          bullets.splice(j, 1);
          e.hp -= 1;
          score += (e.type === "tank" ? 8 : 4);

          if (e.hp <= 0) {
            score += (e.type === "tank" ? 35 : 18);
            enemies.splice(i, 1);
          }
          break;
        }
      }
    }

    // Collisions: boss bullets vs player + enemy bodies vs player
    player.invuln = Math.max(0, player.invuln - dt);
    const hitRadius = player.r * 0.78;

    if (player.invuln <= 0) {
      // boss bullets
      for (let i = 0; i < bossBullets.length; i++) {
        const bb = bossBullets[i];
        if (circleHit(bb.x, bb.y, bb.r, player.x, player.y, hitRadius)) {
          lives -= 1;
          player.invuln = 1.2;
          // small knock
          player.y = clamp(player.y + 18, 20, H - 20);
          break;
        }
      }

      // enemy bodies
      if (lives > 0) {
        for (let i = 0; i < enemies.length; i++) {
          const e = enemies[i];
          if (circleHit(e.x, e.y, e.r * 0.9, player.x, player.y, hitRadius)) {
            lives -= 1;
            player.invuln = 1.2;
            player.y = clamp(player.y + 18, 20, H - 20);
            break;
          }
        }
      }

      // boss body
      if (lives > 0 && boss && circleHit(boss.x, boss.y, boss.r * 0.9, player.x, player.y, hitRadius)) {
        lives -= 1;
        player.invuln = 1.2;
        player.y = clamp(player.y + 18, 20, H - 20);
      }
    }

    if (lives <= 0) {
      gameOver = true;
      paused = false;
      pauseBtn.textContent = "Pause";
    }

    // Hard caps as last-resort safety nets
    if (bullets.length > MAX_BULLETS) bullets.length = MAX_BULLETS;
    if (enemies.length > MAX_ENEMIES) enemies.length = MAX_ENEMIES;
    if (stars.length > MAX_STARS) stars.length = MAX_STARS;
    if (bossBullets.length > MAX_BOSS_BULLETS) bossBullets.length = MAX_BOSS_BULLETS;

    updateHud();
  }

  function fire() {
    if (bullets.length >= MAX_BULLETS) return;

    const spread = Math.max(6, 14 - stage * 0.6);
    bullets.push({ x: player.x - spread, y: player.y - 18, r: 4, v: bulletSpeed });

    if (bullets.length < MAX_BULLETS) {
      bullets.push({ x: player.x + spread, y: player.y - 18, r: 4, v: bulletSpeed });
    }
  }

  // ===== Render =====
  function render(dt) {
    // background
    ctx.fillStyle = "#07080c";
    ctx.fillRect(0, 0, W, H);

    // stars
    ctx.save();
    ctx.globalAlpha = 0.95;
    for (let i = 0; i < stars.length; i++) {
      const st = stars[i];
      ctx.fillStyle = "rgba(225,240,255,0.75)";
      ctx.fillRect(st.x, st.y, st.s, st.s);
    }
    ctx.restore();

    // subtle horizon glow
    const g = ctx.createLinearGradient(0, H, 0, 0);
    g.addColorStop(0, "rgba(60,120,255,0.12)");
    g.addColorStop(0.6, "rgba(60,120,255,0.00)");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, H);

    // boss
    if (boss) drawBoss(boss);

    // enemies
    for (let i = 0; i < enemies.length; i++) drawEnemy(enemies[i]);

    // boss bullets
    for (let i = 0; i < bossBullets.length; i++) {
      const bb = bossBullets[i];
      ctx.beginPath();
      ctx.fillStyle = "rgba(255,180,80,0.95)";
      ctx.arc(bb.x, bb.y, bb.r, 0, Math.PI * 2);
      ctx.fill();
    }

    // player bullets
    for (let i = 0; i < bullets.length; i++) {
      const b = bullets[i];
      ctx.beginPath();
      ctx.fillStyle = "rgba(160,255,210,0.95)";
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fill();
    }

    // player
    drawPlayer();

    // stage intro card (arcade style)
    if (stageIntro) {
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.38)";
      ctx.fillRect(0, 0, W, H);

      ctx.textAlign = "center";
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "900 44px system-ui, sans-serif";
      ctx.fillText(`STAGE ${stage}`, W/2, H/2);

      ctx.font = "700 16px system-ui, sans-serif";
      ctx.fillStyle = "rgba(255,255,255,0.82)";
      ctx.fillText("GET READY", W/2, H/2 + 34);
      ctx.restore();
    }

    if (gameOver) {
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.fillRect(0, 0, W, H);
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.font = "800 26px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("GAME OVER", W/2, H*0.42);
      ctx.font = "700 16px system-ui, sans-serif";
      ctx.fillStyle = "rgba(255,255,255,0.82)";
      ctx.fillText("Tap Restart (top right) or refresh", W/2, H*0.48);
      ctx.restore();
    }
  }

  function drawBoss(b) {
    ctx.save();
    ctx.translate(b.x, b.y);

    // body
    ctx.beginPath();
    ctx.fillStyle = "rgba(170,120,255,0.92)";
    ctx.arc(0, 0, b.r, 0, Math.PI * 2);
    ctx.fill();

    // core
    ctx.beginPath();
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.arc(0, 0, b.r * 0.32, 0, Math.PI * 2);
    ctx.fill();

    // hp bar
    const w = 150;
    const h = 10;
    const pct = clamp(b.hp / b.maxHp, 0, 1);
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(-w/2, -b.r - 26, w, h);
    ctx.fillStyle = "rgba(140,255,180,0.95)";
    ctx.fillRect(-w/2, -b.r - 26, w * pct, h);

    // label
    ctx.textAlign = "center";
    ctx.font = "800 12px system-ui, sans-serif";
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.fillText("BOSS", 0, -b.r - 34);

    ctx.restore();
  }

  function drawPlayer() {
    const p = player;
    ctx.save();
    ctx.translate(p.x, p.y);

    if (p.invuln > 0) ctx.globalAlpha = 0.45 + 0.35 * Math.sin(performance.now() * 0.02);

    ctx.beginPath();
    ctx.fillStyle = "rgba(120,200,255,0.28)";
    ctx.ellipse(0, 16, 10, 18, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.beginPath();
    ctx.fillStyle = "rgba(210,225,255,0.92)";
    ctx.moveTo(0, -18);
    ctx.lineTo(14, 18);
    ctx.lineTo(0, 10);
    ctx.lineTo(-14, 18);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.fillStyle = "rgba(110,255,210,0.85)";
    ctx.arc(0, -3, 5, 0, Math.PI * 2);
    ctx.fill();

    ctx.beginPath();
    ctx.fillStyle = "rgba(255,120,160,0.95)";
    ctx.arc(0, 2, 2.2, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  function drawEnemy(e) {
    ctx.save();
    ctx.translate(e.x, e.y);

    if (e.type === "tank") {
      ctx.beginPath();
      ctx.fillStyle = "rgba(255,170,90,0.95)";
      ctx.moveTo(0, -18);
      ctx.lineTo(18, 0);
      ctx.lineTo(0, 18);
      ctx.lineTo(-18, 0);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.arc(0, 0, 7, 0, Math.PI * 2);
      ctx.fill();

      for (let i = 0; i < e.hp; i++) {
        ctx.beginPath();
        ctx.fillStyle = "rgba(255,255,255,0.75)";
        ctx.arc(-12 + i*8, -24, 2.2, 0, Math.PI*2);
        ctx.fill();
      }
    } else {
      ctx.beginPath();
      ctx.fillStyle = "rgba(255,90,120,0.95)";
      ctx.arc(0, 0, 14, 0, Math.PI*2);
      ctx.fill();

      ctx.beginPath();
      ctx.strokeStyle = "rgba(255,255,255,0.65)";
      ctx.lineWidth = 2;
      ctx.moveTo(-10, -6);
      ctx.lineTo(10, 6);
      ctx.moveTo(10, -6);
      ctx.lineTo(-10, 6);
      ctx.stroke();
    }

    ctx.restore();
  }

  function drawPaused() {
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.font = "800 24px system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("PAUSED", W/2, H/2);
    ctx.font = "600 14px system-ui, sans-serif";
    ctx.fillStyle = "rgba(255,255,255,0.80)";
    ctx.fillText("Tap Resume or press P", W/2, H/2 + 26);
    ctx.restore();
  }

  // ===== Start initial state =====
  reset();
})();
</script>
</body>
</html>
