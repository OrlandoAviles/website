<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>ToV - Marketplace Hub (Low Poly)</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#8fd3ff; }
    canvas { display:block; }
    .hud{
      position:fixed; top:12px; left:12px;
      padding:10px 12px;
      font:14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color:rgba(0,0,0,.80);
      background:rgba(255,255,255,.60);
      border:1px solid rgba(0,0,0,.08);
      border-radius:12px;
      backdrop-filter: blur(8px);
      z-index:10;
      user-select:none;
    }
    .hint{
      position:fixed; bottom:12px; left:12px;
      padding:8px 10px;
      font:12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color:rgba(0,0,0,.75);
      background:rgba(255,255,255,.55);
      border:1px solid rgba(0,0,0,.08);
      border-radius:12px;
      backdrop-filter: blur(8px);
      z-index:10;
      user-select:none;
    }
  </style>
</head>
<body>
  <div class="hud">ToV Marketplace Hub • textures: stone + cloth + runes</div>
  <div class="hint">Drag: rotate • Wheel: zoom • Shift+Drag: pan</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
    if (!window.THREE) throw new Error("THREE failed to load");

    // =========================================================
    //  TEXTURE FORGE (procedural textures, no external images)
    // =========================================================
    function makeCanvasTexture(w, h, drawFn) {
      const c = document.createElement("canvas");
      c.width = w; c.height = h;
      const ctx = c.getContext("2d");
      drawFn(ctx, w, h);

      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = THREE.RepeatWrapping;
      tex.wrapT = THREE.RepeatWrapping;
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.needsUpdate = true;
      return tex;
    }

    function rand(seed) {
      // tiny deterministic PRNG (mulberry32)
      let t = seed >>> 0;
      return function() {
        t += 0x6D2B79F5;
        let r = Math.imul(t ^ (t >>> 15), 1 | t);
        r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
        return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
      }
    }

    function genStoneTilesTexture(seed=1337) {
      const r = rand(seed);
      return makeCanvasTexture(512, 512, (ctx, w, h) => {
        // base
        ctx.fillStyle = "#5b6773";
        ctx.fillRect(0,0,w,h);

        // subtle noise wash
        for (let i=0;i<18000;i++){
          const x = (r()*w)|0;
          const y = (r()*h)|0;
          const a = 0.06 + r()*0.12;
          const v = 40 + (r()*60)|0;
          ctx.fillStyle = `rgba(${v},${v},${v},${a})`;
          ctx.fillRect(x,y,1,1);
        }

        // tile grid
        const tile = 64;
        ctx.lineWidth = 3;
        ctx.strokeStyle = "rgba(0,0,0,0.25)";
        for (let x=0; x<=w; x+=tile){
          ctx.beginPath();
          ctx.moveTo(x,0);
          ctx.lineTo(x,h);
          ctx.stroke();
        }
        for (let y=0; y<=h; y+=tile){
          ctx.beginPath();
          ctx.moveTo(0,y);
          ctx.lineTo(w,y);
          ctx.stroke();
        }

        // crack lines
        ctx.lineWidth = 2;
        for (let i=0; i<45; i++){
          const x0 = r()*w;
          const y0 = r()*h;
          const len = 30 + r()*90;
          const ang = r()*Math.PI*2;

          ctx.strokeStyle = `rgba(0,0,0,${0.12+r()*0.12})`;
          ctx.beginPath();
          ctx.moveTo(x0,y0);

          let x=x0, y=y0;
          const steps = 8 + (r()*10)|0;
          for (let s=0; s<steps; s++){
            x += Math.cos(ang + (r()-0.5)*0.9) * (len/steps);
            y += Math.sin(ang + (r()-0.5)*0.9) * (len/steps);
            ctx.lineTo(x,y);
          }
          ctx.stroke();
        }

        // edge darkening
        const grad = ctx.createRadialGradient(w/2,h/2,20, w/2,h/2, w*0.75);
        grad.addColorStop(0, "rgba(255,255,255,0.05)");
        grad.addColorStop(1, "rgba(0,0,0,0.18)");
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,w,h);
      });
    }

    function genStripedClothTexture(primary="#b3363a", seed=777) {
      const r = rand(seed);
      return makeCanvasTexture(512, 512, (ctx, w, h) => {
        ctx.fillStyle = primary;
        ctx.fillRect(0,0,w,h);

        // diagonal stripes
        ctx.save();
        ctx.translate(w/2, h/2);
        ctx.rotate(-Math.PI/6);
        ctx.translate(-w/2, -h/2);

        const stripeW = 38;
        for (let x=-w; x<w*2; x+=stripeW){
          const alt = ((x/stripeW)|0) % 2 === 0;
          ctx.fillStyle = alt ? "rgba(255,255,255,0.18)" : "rgba(0,0,0,0.10)";
          ctx.fillRect(x, 0, stripeW*0.55, h);
        }
        ctx.restore();

        // cloth weave noise
        for (let i=0;i<12000;i++){
          const x = (r()*w)|0;
          const y = (r()*h)|0;
          const a = 0.03 + r()*0.05;
          ctx.fillStyle = `rgba(255,255,255,${a})`;
          ctx.fillRect(x,y,1,1);
        }

        // subtle vignette to make it feel like fabric folds
        const grad = ctx.createRadialGradient(w/2,h/2,10, w/2,h/2, w*0.75);
        grad.addColorStop(0, "rgba(255,255,255,0.10)");
        grad.addColorStop(1, "rgba(0,0,0,0.20)");
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,w,h);
      });
    }

    function genRuneSigilTexture(seed=9001) {
      const r = rand(seed);
      return makeCanvasTexture(512, 512, (ctx, w, h) => {
        ctx.fillStyle = "rgba(0,0,0,0)";
        ctx.clearRect(0,0,w,h);

        const cx=w/2, cy=h/2;

        // outer glow haze
        const haze = ctx.createRadialGradient(cx,cy,30,cx,cy,230);
        haze.addColorStop(0,"rgba(120,245,255,0.35)");
        haze.addColorStop(1,"rgba(120,245,255,0)");
        ctx.fillStyle = haze;
        ctx.beginPath();
        ctx.arc(cx,cy,230,0,Math.PI*2);
        ctx.fill();

        // rings
        ctx.strokeStyle = "rgba(210,255,255,0.78)";
        ctx.lineWidth = 6;
        ctx.beginPath(); ctx.arc(cx,cy,170,0,Math.PI*2); ctx.stroke();
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(cx,cy,140,0,Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.arc(cx,cy,90,0,Math.PI*2); ctx.stroke();

        // radial runes (stylized glyph lines)
        ctx.lineCap = "round";
        for (let i=0;i<18;i++){
          const a = (i/18)*Math.PI*2;
          const inner = 95 + r()*10;
          const outer = 135 + r()*15;
          const x0 = cx + Math.cos(a)*inner;
          const y0 = cy + Math.sin(a)*inner;
          const x1 = cx + Math.cos(a)*outer;
          const y1 = cy + Math.sin(a)*outer;

          ctx.strokeStyle = "rgba(180,255,255,0.65)";
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(x0,y0);
          ctx.lineTo(x1,y1);
          ctx.stroke();

          // little rune branches
          const b = a + (r()-0.5)*0.8;
          const bx = cx + Math.cos(b)*(inner + 25);
          const by = cy + Math.sin(b)*(inner + 25);

          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(bx,by);
          ctx.lineTo(bx + (r()-0.5)*22, by + (r()-0.5)*22);
          ctx.stroke();
        }

        // center star
        ctx.strokeStyle = "rgba(230,255,255,0.9)";
        ctx.lineWidth = 4;
        for (let i=0;i<6;i++){
          const a = (i/6)*Math.PI*2;
          ctx.beginPath();
          ctx.moveTo(cx,cy);
          ctx.lineTo(cx+Math.cos(a)*65, cy+Math.sin(a)*65);
          ctx.stroke();
        }

        // center dot glow
        const core = ctx.createRadialGradient(cx,cy,0,cx,cy,30);
        core.addColorStop(0,"rgba(255,255,255,0.95)");
        core.addColorStop(1,"rgba(120,245,255,0)");
        ctx.fillStyle = core;
        ctx.beginPath();
        ctx.arc(cx,cy,30,0,Math.PI*2);
        ctx.fill();
      });
    }

    // =========================================================
    //  SCENE
    // =========================================================
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x8fd3ff, 18, 85);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 250);
    camera.position.set(12, 10, 16);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.setClearColor(0x8fd3ff, 1);
    document.body.appendChild(renderer.domElement);

    // ---------- gradient sky ----------
    function makeGradientTexture(topHex, bottomHex) {
      const c = document.createElement("canvas");
      c.width = 2;
      c.height = 512;
      const ctx = c.getContext("2d");
      const grad = ctx.createLinearGradient(0, 0, 0, c.height);
      grad.addColorStop(0, topHex);
      grad.addColorStop(1, bottomHex);
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,c.width,c.height);
      const tex = new THREE.CanvasTexture(c);
      tex.magFilter = THREE.LinearFilter;
      tex.minFilter = THREE.LinearMipMapLinearFilter;
      tex.wrapS = THREE.ClampToEdgeWrapping;
      tex.wrapT = THREE.ClampToEdgeWrapping;
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.needsUpdate = true;
      return tex;
    }

    const skyTex = makeGradientTexture("#78c7ff", "#d6f4ff");
    const skyPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(500, 260),
      new THREE.MeshBasicMaterial({ map: skyTex, depthWrite: false })
    );
    skyPlane.position.set(0, 65, -140);
    scene.add(skyPlane);

    // ---------- simple camera controls ----------
    const controls = {
      target: new THREE.Vector3(0, 2, 0),
      radius: 22,
      theta: Math.PI * 0.25,
      phi: Math.PI * 0.30,
      rotateSpeed: 0.006,
      panSpeed: 0.01,
      zoomSpeed: 0.002,
      minRadius: 8,
      maxRadius: 65
    };

    function updateCameraFromControls() {
      const { target, radius, theta, phi } = controls;
      const x = target.x + radius * Math.sin(phi) * Math.cos(theta);
      const z = target.z + radius * Math.sin(phi) * Math.sin(theta);
      const y = target.y + radius * Math.cos(phi);
      camera.position.set(x, y, z);
      camera.lookAt(target);
    }
    updateCameraFromControls();

    let isDown = false;
    let lastX = 0, lastY = 0;
    let shift = false;

    window.addEventListener("keydown", (e)=>{ if (e.key === "Shift") shift = true; });
    window.addEventListener("keyup", (e)=>{ if (e.key === "Shift") shift = false; });

    renderer.domElement.addEventListener("mousedown", (e)=>{
      isDown = true;
      lastX = e.clientX;
      lastY = e.clientY;
    });
    window.addEventListener("mouseup", ()=> isDown = false);

    window.addEventListener("mousemove", (e)=>{
      if (!isDown) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;

      if (shift) {
        const panX = -dx * controls.panSpeed;
        const panY = dy * controls.panSpeed;

        const right = new THREE.Vector3();
        camera.getWorldDirection(right);
        right.cross(camera.up).normalize();

        const up = camera.up.clone().normalize();
        controls.target.add(right.multiplyScalar(panX));
        controls.target.add(up.multiplyScalar(panY));
      } else {
        controls.theta -= dx * controls.rotateSpeed;
        controls.phi -= dy * controls.rotateSpeed;
        controls.phi = Math.max(0.15, Math.min(Math.PI - 0.15, controls.phi));
      }
      updateCameraFromControls();
    });

    window.addEventListener("wheel", (e)=>{
      controls.radius += e.deltaY * controls.zoomSpeed;
      controls.radius = Math.max(controls.minRadius, Math.min(controls.maxRadius, controls.radius));
      updateCameraFromControls();
    }, { passive:true });

    // ---------- lighting ----------
    scene.add(new THREE.HemisphereLight(0xdff5ff, 0x5b6771, 0.85));
    const sun = new THREE.DirectionalLight(0xffffff, 1.05);
    sun.position.set(16, 24, 10);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    sun.shadow.camera.left = -40;
    sun.shadow.camera.right = 40;
    sun.shadow.camera.top = 40;
    sun.shadow.camera.bottom = -40;
    scene.add(sun);

    // ---------- procedural textures ----------
    const stoneTex = genStoneTilesTexture(1337);
    stoneTex.repeat.set(6, 6);

    const clothRedTex = genStripedClothTexture("#b3363a", 111);
    clothRedTex.repeat.set(2, 2);

    const clothBlueTex = genStripedClothTexture("#2a6fb0", 222);
    clothBlueTex.repeat.set(2, 2);

    const runeTex = genRuneSigilTexture(9001);

    // ---------- materials ----------
    const MAT = {
      stone: new THREE.MeshStandardMaterial({
        color: 0xffffff,
        map: stoneTex,
        roughness: 0.98,
        metalness: 0.02
      }),
      stoneDark: new THREE.MeshStandardMaterial({ color: 0x343c46, roughness: 0.99, metalness: 0.02 }),
      wood: new THREE.MeshStandardMaterial({ color: 0x6a4f3b, roughness: 0.9 }),
      clothRed: new THREE.MeshStandardMaterial({ color: 0xffffff, map: clothRedTex, roughness: 0.9 }),
      clothBlue: new THREE.MeshStandardMaterial({ color: 0xffffff, map: clothBlueTex, roughness: 0.9 }),
      brass: new THREE.MeshStandardMaterial({ color: 0xc7a75a, roughness: 0.35, metalness: 0.75 }),
      crystal: new THREE.MeshStandardMaterial({
        color: 0x6ef7ff,
        emissive: 0x38c8ff,
        emissiveIntensity: 1.4,
        roughness: 0.18,
        metalness: 0.12,
        transparent: true,
        opacity: 0.92
      }),
      runeDecal: new THREE.MeshBasicMaterial({
        map: runeTex,
        transparent: true,
        opacity: 1,
        depthWrite: false
      }),
      water: new THREE.PointsMaterial({ color: 0x48baff, size: 0.08, transparent: true, opacity: 0.85 }),
      sparkle: new THREE.PointsMaterial({ color: 0xc9fbff, size: 0.06, transparent: true, opacity: 0.9 })
    };

    function mesh(geo, mat, x=0, y=0, z=0) {
      const m = new THREE.Mesh(geo, mat);
      m.position.set(x,y,z);
      m.castShadow = true;
      m.receiveShadow = true;
      return m;
    }

    // ---------- ground ----------
    function addPlaza() {
      scene.add(mesh(new THREE.BoxGeometry(36, 1, 36), MAT.stoneDark, 0, -0.5, 0));

      // main textured plaza plane (helps avoid stretching on individual tiles)
      const plaza = mesh(new THREE.PlaneGeometry(32, 32), MAT.stone, 0, 0.03, 0);
      plaza.rotation.x = -Math.PI/2;
      plaza.castShadow = false;
      plaza.receiveShadow = true;
      scene.add(plaza);
    }

    // ---------- props ----------
    function makeVendorStall(x, z, cloth="red") {
      const g = new THREE.Group();
      g.add(mesh(new THREE.BoxGeometry(3.2, 0.35, 2.6), MAT.stoneDark, 0, 0.175, 0));

      const postGeo = new THREE.BoxGeometry(0.18, 2.4, 0.18);
      g.add(mesh(postGeo, MAT.wood, -1.4, 1.2, -1.1));
      g.add(mesh(postGeo, MAT.wood,  1.4, 1.2, -1.1));
      g.add(mesh(postGeo, MAT.wood, -1.4, 1.2,  1.1));
      g.add(mesh(postGeo, MAT.wood,  1.4, 1.2,  1.1));

      const canopyMat = cloth === "blue" ? MAT.clothBlue : MAT.clothRed;
      const canopy = mesh(new THREE.ConeGeometry(2.2, 1.0, 4), canopyMat, 0, 2.65, 0);
      canopy.rotation.y = Math.PI * 0.25;
      g.add(canopy);

      g.add(mesh(new THREE.BoxGeometry(2.4, 0.22, 1.1), MAT.wood, 0, 0.85, 0.35));
      g.add(mesh(new THREE.BoxGeometry(1.5, 0.45, 0.12), MAT.brass, 0, 2.05, -1.35));
      g.add(mesh(new THREE.BoxGeometry(0.7, 0.7, 0.7), MAT.wood, -1.0, 0.7, 0.9));
      g.add(mesh(new THREE.BoxGeometry(0.6, 0.4, 0.6), MAT.wood,  1.0, 0.6, 0.9));

      g.position.set(x, 0, z);
      scene.add(g);
      return g;
    }

    function makeCrate(x, z) { scene.add(mesh(new THREE.BoxGeometry(0.9,0.9,0.9), MAT.wood, x, 0.45, z)); }
    function makeBarrel(x, z) {
      const b = mesh(new THREE.CylinderGeometry(0.42, 0.5, 1.0, 10), MAT.wood, x, 0.5, z);
      b.rotation.y = Math.random() * Math.PI;
      scene.add(b);
    }

    function makeLanternPost(x, z) {
      const g = new THREE.Group();
      g.add(mesh(new THREE.CylinderGeometry(0.08, 0.1, 3.2, 8), MAT.wood, 0, 1.6, 0));
      g.add(mesh(new THREE.BoxGeometry(1.2, 0.12, 0.12), MAT.wood, 0.45, 2.6, 0));

      const lampMat = new THREE.MeshStandardMaterial({
        color: 0xfff1c2, emissive: 0xffcc66, emissiveIntensity: 1.5, roughness: 0.35
      });
      g.add(mesh(new THREE.SphereGeometry(0.22, 10, 10), lampMat, 1.05, 2.5, 0));

      const light = new THREE.PointLight(0xffcc66, 1.1, 9, 2);
      light.position.set(1.05, 2.5, 0);
      g.add(light);

      g.position.set(x, 0, z);
      scene.add(g);
      return g;
    }

    function makeFountain(x, z) {
      const g = new THREE.Group();
      g.add(mesh(new THREE.CylinderGeometry(2.4, 2.6, 0.7, 14), MAT.stoneDark, 0, 0.35, 0));
      g.add(mesh(new THREE.CylinderGeometry(2.0, 2.0, 0.4, 14), MAT.stone, 0, 0.6, 0));
      g.add(mesh(new THREE.CylinderGeometry(0.35, 0.55, 2.6, 12), MAT.stoneDark, 0, 1.8, 0));
      g.add(mesh(new THREE.CylinderGeometry(0.9, 1.15, 0.35, 14), MAT.stoneDark, 0, 3.2, 0));
      g.position.set(x, 0, z);
      scene.add(g);

      const count = 520;
      const positions = new Float32Array(count * 3);
      const velocities = new Float32Array(count * 3);

      function respawn(i) {
        const ix = i*3;
        positions[ix+0] = (Math.random()-0.5) * 0.25;
        positions[ix+1] = 3.35 + Math.random() * 0.2;
        positions[ix+2] = (Math.random()-0.5) * 0.25;

        velocities[ix+0] = (Math.random()-0.5) * 1.0;
        velocities[ix+1] = 3.0 + Math.random() * 1.4;
        velocities[ix+2] = (Math.random()-0.5) * 1.0;
      }
      for (let i=0; i<count; i++) respawn(i);

      const waterGeo = new THREE.BufferGeometry();
      waterGeo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      const water = new THREE.Points(waterGeo, MAT.water);
      water.position.set(x, 0, z);
      scene.add(water);

      return { water, positions, velocities, count, respawn };
    }

    function makeSaveCrystal(x, z) {
      const g = new THREE.Group();
      g.add(mesh(new THREE.CylinderGeometry(1.2, 1.4, 0.6, 10), MAT.stoneDark, 0, 0.3, 0));

      const ring = mesh(new THREE.TorusGeometry(1.0, 0.08, 8, 22), MAT.brass, 0, 0.65, 0);
      ring.rotation.x = Math.PI * 0.5;
      g.add(ring);

      const crystalGeo = new THREE.OctahedronGeometry(0.9, 0);
      const crystal = mesh(crystalGeo, MAT.crystal, 0, 1.75, 0);
      crystal.scale.set(1.0, 2.0, 1.0);
      g.add(crystal);

      // rune decal plane
      const sigil = new THREE.Mesh(new THREE.CircleGeometry(1.9, 48), MAT.runeDecal);
      sigil.rotation.x = -Math.PI/2;
      sigil.position.set(0, 0.66, 0);
      g.add(sigil);

      const glow = new THREE.PointLight(0x66f2ff, 2.0, 18, 2);
      glow.position.set(0, 2.2, 0);
      g.add(glow);

      g.position.set(x, 0, z);
      scene.add(g);

      return { group: g, crystal, ring, sigil };
    }

    function makeCrystalSparkles(anchorGroup) {
      const count = 220;
      const positions = new Float32Array(count * 3);
      const meta = new Float32Array(count * 4);

      for (let i=0; i<count; i++){
        const ix = i*3;
        const mx = i*4;

        const radius = 0.6 + Math.random() * 2.0;
        const angle = Math.random() * Math.PI * 2;
        const height = 0.9 + Math.random() * 2.5;
        const speed = 0.35 + Math.random() * 1.0;

        meta[mx+0] = angle;
        meta[mx+1] = radius;
        meta[mx+2] = height;
        meta[mx+3] = speed;

        positions[ix+0] = Math.cos(angle) * radius;
        positions[ix+1] = height;
        positions[ix+2] = Math.sin(angle) * radius;
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      const pts = new THREE.Points(geo, MAT.sparkle);
      anchorGroup.add(pts);

      return { pts, positions, meta, count };
    }

    // ---------- build ----------
    addPlaza();

    makeVendorStall(-7, -4, "red");
    makeVendorStall( 7, -4, "blue");
    makeVendorStall(-7,  6, "blue");
    makeVendorStall( 7,  6, "red");

    makeCrate(-5.2, 0.0);
    makeCrate(-5.9, 0.8);
    makeBarrel(5.4, 0.0);
    makeBarrel(6.2, 0.7);

    makeLanternPost(-3.5, -10.5);
    makeLanternPost( 3.5, -10.5);
    makeLanternPost(-3.5,  12.0);
    makeLanternPost( 3.5,  12.0);

    const fountain = makeFountain(0, 0);
    const save = makeSaveCrystal(0, 9);
    const sparkles = makeCrystalSparkles(save.group);

    // ---------- animation ----------
    const clock = new THREE.Clock();

    function animate(){
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();

      // crystal pulse
      const pulse = 1 + Math.sin(t * 2.1) * 0.06;
      save.crystal.scale.set(1*pulse, 2*pulse, 1*pulse);
      save.crystal.rotation.y += 0.01;
      save.ring.rotation.z += 0.012;

      // rune sigil pulse
      save.sigil.material.opacity = 0.55 + (Math.sin(t*2.5)*0.15);

      // sparkles orbit
      for (let i=0; i<sparkles.count; i++){
        const ix = i*3;
        const mx = i*4;

        const angle0 = sparkles.meta[mx+0];
        const radius = sparkles.meta[mx+1];
        const height = sparkles.meta[mx+2];
        const speed  = sparkles.meta[mx+3];

        const angle = angle0 + t * speed;

        sparkles.positions[ix+0] = Math.cos(angle) * radius;
        sparkles.positions[ix+2] = Math.sin(angle) * radius;
        sparkles.positions[ix+1] = height + Math.sin(t*2.4 + angle0*3.0) * 0.08;
      }
      sparkles.pts.geometry.attributes.position.needsUpdate = true;

      // fountain physics
      const gravity = -6.4;
      for (let i=0; i<fountain.count; i++) {
        const ix = i*3;
        fountain.positions[ix+0] += fountain.velocities[ix+0] * 0.016;
        fountain.positions[ix+1] += fountain.velocities[ix+1] * 0.016;
        fountain.positions[ix+2] += fountain.velocities[ix+2] * 0.016;

        fountain.velocities[ix+1] += gravity * 0.016;

        if (fountain.positions[ix+1] < 0.85) fountain.respawn(i);
      }
      fountain.water.geometry.attributes.position.needsUpdate = true;

      renderer.render(scene, camera);
    }
    animate();

    addEventListener("resize", () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
