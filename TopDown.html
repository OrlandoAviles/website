<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Top-Down Field + Combat Scene Switch</title>

<style>
html, body {
  height: 100%;
  margin: 0;
  background: #0b0e14;
  overflow: hidden;
  touch-action: none;
}

/* ===== FIELD ===== */
#wrap {
  position: fixed;
  inset: 0;
  display: grid;
  place-items: center;
}

canvas {
  width: 100vw;
  height: 100vh;
  display: block;
}

/* Hint */
.hint {
  position: fixed;
  top: 10px;
  left: 10px;
  font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial;
  color: rgba(255,255,255,.75);
  background: rgba(0,0,0,.35);
  padding: 8px 10px;
  border-radius: 10px;
  user-select: none;
  pointer-events: none;
  z-index: 2;
}

/* ===== COMBAT OVERLAY ===== */
#combatOverlay {
  position: fixed;
  inset: 0;
  background: black;
  display: none;
  z-index: 10;
}

#combatFrame {
  width: 100%;
  height: 100%;
  border: none;
}
</style>
</head>

<body>

<div class="hint">Move: Joystick (left side) or WASD / Arrows</div>

<div id="wrap">
  <canvas id="c"></canvas>
</div>

<div id="combatOverlay">
  <iframe id="combatFrame"></iframe>
</div>

<script>
/* =========================================================
   CORE STATE
========================================================= */
let gameState = "field"; // "field" | "combat"

/* =========================================================
   CANVAS SETUP
========================================================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize() {
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  canvas.width = Math.floor(innerWidth * dpr);
  canvas.height = Math.floor(innerHeight * dpr);
  canvas.style.width = innerWidth + "px";
  canvas.style.height = innerHeight + "px";
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
addEventListener("resize", resize);
resize();

/* =========================================================
   PLAYER
========================================================= */
const player = {
  x: innerWidth * 0.5,
  y: innerHeight * 0.5,
  r: 16,
  speed: 240,
  vx: 0,
  vy: 0
};

/* =========================================================
   INPUT
========================================================= */
const keys = new Set();
addEventListener("keydown", e => keys.add(e.key.toLowerCase()));
addEventListener("keyup", e => keys.delete(e.key.toLowerCase()));

function keyboardAxis() {
  let x = 0, y = 0;
  if (keys.has("arrowleft") || keys.has("a")) x -= 1;
  if (keys.has("arrowright") || keys.has("d")) x += 1;
  if (keys.has("arrowup") || keys.has("w")) y -= 1;
  if (keys.has("arrowdown") || keys.has("s")) y += 1;
  const len = Math.hypot(x, y);
  if (len > 0) { x /= len; y /= len; }
  return { x, y };
}

/* =========================================================
   VIRTUAL JOYSTICK
========================================================= */
const joy = {
  active: false,
  id: null,
  baseX: 0, baseY: 0,
  knobX: 0, knobY: 0,
  max: 52,
  dead: 0.10,
  axisX: 0, axisY: 0
};

function setJoy(px, py) {
  const dx = px - joy.baseX;
  const dy = py - joy.baseY;
  const dist = Math.hypot(dx, dy);
  const clamped = Math.min(dist, joy.max);
  const nx = dist ? dx / dist : 0;
  const ny = dist ? dy / dist : 0;

  joy.knobX = joy.baseX + nx * clamped;
  joy.knobY = joy.baseY + ny * clamped;

  let ax = (nx * clamped) / joy.max;
  let ay = (ny * clamped) / joy.max;
  const alen = Math.hypot(ax, ay);

  if (alen < joy.dead) {
    ax = ay = 0;
  } else {
    const t = (alen - joy.dead) / (1 - joy.dead);
    ax = (ax / alen) * t;
    ay = (ay / alen) * t;
  }

  joy.axisX = ax;
  joy.axisY = ay;
}

canvas.addEventListener("pointerdown", e => {
  canvas.setPointerCapture(e.pointerId);
  if (!joy.active) {
    joy.active = true;
    joy.id = e.pointerId;
    joy.baseX = e.clientX;
    joy.baseY = e.clientY;
    joy.knobX = e.clientX;
    joy.knobY = e.clientY;
  }
});

canvas.addEventListener("pointermove", e => {
  if (joy.active && e.pointerId === joy.id) {
    setJoy(e.clientX, e.clientY);
  }
});

function endJoy(e) {
  if (e.pointerId === joy.id) {
    joy.active = false;
    joy.id = null;
    joy.axisX = joy.axisY = 0;
  }
}
canvas.addEventListener("pointerup", endJoy);
canvas.addEventListener("pointercancel", endJoy);
canvas.addEventListener("pointerout", endJoy);

/* =========================================================
   RANDOM ENCOUNTERS
========================================================= */
let encounterTimer = 0;

function tryEncounter(dt) {
  encounterTimer += dt;
  if (encounterTimer > 3) {
    encounterTimer = 0;
    if (Math.random() < 0.25) {
      startCombat();
    }
  }
}

/* =========================================================
   SCENE SWITCHING
========================================================= */
function startCombat() {
  gameState = "combat";
  document.getElementById("combatOverlay").style.display = "block";
  document.getElementById("combatFrame").src = "FF13 3v1.html";
}

window.addEventListener("message", e => {
  if (e.data === "combatEnd") {
    document.getElementById("combatOverlay").style.display = "none";
    document.getElementById("combatFrame").src = "";
    gameState = "field";
    last = performance.now();
    requestAnimationFrame(tick);
  }
});

/* =========================================================
   GAME LOOP
========================================================= */
let last = performance.now();
function tick(now) {
  if (gameState !== "field") return;

  const dt = Math.min(0.05, (now - last) / 1000);
  last = now;

  const kb = keyboardAxis();
  let ax = kb.x, ay = kb.y;
  if (joy.axisX || joy.axisY) {
    ax = joy.axisX;
    ay = joy.axisY;
  }

  player.vx = ax * player.speed;
  player.vy = ay * player.speed;
  player.x += player.vx * dt;
  player.y += player.vy * dt;

  player.x = Math.max(player.r, Math.min(innerWidth - player.r, player.x));
  player.y = Math.max(player.r, Math.min(innerHeight - player.r, player.y));

  tryEncounter(dt);
  draw();
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* =========================================================
   RENDERING
========================================================= */
function drawGrid(spacing = 48) {
  ctx.globalAlpha = 0.18;
  ctx.strokeStyle = "#9bdcff";
  for (let x = 0; x <= innerWidth; x += spacing) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, innerHeight); ctx.stroke();
  }
  for (let y = 0; y <= innerHeight; y += spacing) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(innerWidth, y); ctx.stroke();
  }
  ctx.globalAlpha = 1;
}

function drawPlayer() {
  ctx.fillStyle = "#7CFF8A";
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
  ctx.fill();
}

function drawJoystick() {
  if (!joy.active) return;
  ctx.globalAlpha = 0.6;
  ctx.fillStyle = "#1b2433";
  ctx.beginPath();
  ctx.arc(joy.baseX, joy.baseY, joy.max, 0, Math.PI * 2);
  ctx.fill();

  ctx.globalAlpha = 0.9;
  ctx.fillStyle = "#9bdcff";
  ctx.beginPath();
  ctx.arc(joy.knobX, joy.knobY, joy.max * 0.45, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;
}

function draw() {
  ctx.clearRect(0, 0, innerWidth, innerHeight);
  ctx.fillStyle = "#0b0e14";
  ctx.fillRect(0, 0, innerWidth, innerHeight);
  drawGrid();
  drawPlayer();
  drawJoystick();
}
</script>

</body>
</html>
