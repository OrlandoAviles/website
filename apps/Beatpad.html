<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Beatpad + Timeline (Mini DAW)</title>
  <style>
    :root{
      --bg:#0f0f12; --panel:#17171c; --panel2:#121216; --border:#2d2d35;
      --text:#eee; --muted:rgba(255,255,255,.72);
    }
    body{margin:0;font-family:system-ui,sans-serif;background:var(--bg);color:var(--text);}
    .app{width:min(1100px,98vw);margin:16px auto;}
    h1{margin:0 0 8px;font-size:18px;opacity:.95;}
    .muted{opacity:.75;font-size:13px;}
    .panel{border:1px solid var(--border);background:var(--panel);border-radius:16px;padding:14px;box-shadow:0 14px 40px rgba(0,0,0,.45)}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:10px}
    button{border-radius:12px;border:1px solid #444;background:#23232b;color:#fff;padding:10px 12px;cursor:pointer}
    button.primary{background:#2a2a42;border-color:#5757aa}
    button.danger{background:#382023;border-color:#a35}
    .pill{display:inline-flex;gap:8px;align-items:center;border:1px solid var(--border);background:var(--panel2);padding:8px 10px;border-radius:999px;font-size:13px;opacity:.95}
    input[type=range]{width:220px}

    /* Beat pads */
    .pads{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-top:12px}
    .pad{height:84px;border-radius:14px;border:1px solid #444;background:#202028;color:#fff;font-size:16px;cursor:pointer;user-select:none;touch-action:none;-webkit-tap-highlight-color:transparent}
    .pad:active{transform:scale(.985);filter:brightness(1.15)}

    /* Timeline */
    .timelineWrap{margin-top:14px;border:1px solid var(--border);background:var(--panel2);border-radius:16px;padding:10px}
    canvas{width:100%;height:220px;border-radius:12px;background:#0d0d12;border:1px solid #23232d;display:block}
    .hint{margin-top:8px}
  </style>
</head>
<body>
<div class="app">
  <div class="panel">
    <h1>ü•Å Beatpad + Timeline (Mini DAW Layer)</h1>
    <div class="muted">Record a performance ‚Üí it becomes a Clip ‚Üí drag it on the bar timeline like a DAW.</div>

    <div class="row">
      <button id="btnStartAudio" class="primary">üîä Start Audio</button>
      <button id="btnMetro">üï∞Ô∏è Metronome</button>
      <button id="btnRecord" class="danger">‚è∫ Record Take</button>
      <button id="btnStop">‚èπ Stop</button>
      <button id="btnPlay" class="primary">‚ñ∂Ô∏è Play Timeline</button>
      <button id="btnAddClip">‚ûï Make Clip from Take</button>
      <button id="btnClearClips">üßΩ Clear Clips</button>
    </div>

    <div class="row">
      <span class="pill">BPM: <code id="bpmLabel">120</code></span>
      <input id="bpm" type="range" min="60" max="200" value="120" />
      <span class="pill">Latency: <code id="latLabel">45</code>ms</span>
      <input id="lat" type="range" min="0" max="120" value="45" />
      <span class="pill">Zoom: <code id="zoomLabel">1.00</code>x</span>
      <input id="zoom" type="range" min="0.5" max="3" step="0.05" value="1" />
    </div>

    <div class="row">
      <span class="pill" id="status">Status: <code>idle</code></span>
      <span class="pill">Take hits: <code id="takeHits">0</code></span>
      <span class="pill">Clips: <code id="clipCount">0</code></span>
      <span class="pill">Playhead: <code id="playheadLabel">bar 1</code></span>
    </div>

    <div class="pads" id="pads"></div>

    <div class="timelineWrap">
      <canvas id="timeline" width="1200" height="220"></canvas>
      <div class="muted hint">Timeline controls: click to set playhead ‚Ä¢ drag clips to reposition ‚Ä¢ drag clip edges to resize ‚Ä¢ Alt/Option+drag to duplicate</div>
    </div>
  </div>
</div>

<script>
/**********************
 * AUDIO + BEATPAD
 **********************/
let audioCtx=null, master=null;
function ensureAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  master = audioCtx.createGain();
  master.gain.value=0.9;
  master.connect(audioCtx.destination);
}
function now(){return audioCtx.currentTime;}

const timing={ scheduleAhead:0.06, inputLatency:0.045 };

const state={
  bpm:120,
  metronomeOn:false,
  metroTimer:null,
  metroNext:0,

  isRecording:false,
  takeStart:0,
  takeHits:[], // {padId, t}
  takeLength:0,

  // transport
  isPlaying:false,
  transportStartCtxTime:0,
  transportStartBar:1,
  playheadBar:1,

  // timeline view
  zoom:1.0,
};

function secondsPerBeat(){return 60/state.bpm;}
function secondsPerBar(){return secondsPerBeat()*4;}

// basic drum synth
function triggerKick(at){
  const o=audioCtx.createOscillator();
  const g=audioCtx.createGain();
  o.type='sine';
  o.frequency.setValueAtTime(170,at);
  o.frequency.exponentialRampToValueAtTime(45,at+0.09);
  g.gain.setValueAtTime(0.0001,at);
  g.gain.exponentialRampToValueAtTime(1.0,at+0.005);
  g.gain.exponentialRampToValueAtTime(0.0001,at+0.24);
  o.connect(g); g.connect(master);
  o.start(at); o.stop(at+0.3);
}
function triggerHat(at){
  const buf=audioCtx.createBuffer(1,audioCtx.sampleRate*0.06,audioCtx.sampleRate);
  const d=buf.getChannelData(0);
  for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1);
  const s=audioCtx.createBufferSource(); s.buffer=buf;
  const hp=audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=7000;
  const g=audioCtx.createGain();
  g.gain.setValueAtTime(0.0001,at);
  g.gain.exponentialRampToValueAtTime(0.45,at+0.001);
  g.gain.exponentialRampToValueAtTime(0.0001,at+0.05);
  s.connect(hp); hp.connect(g); g.connect(master);
  s.start(at); s.stop(at+0.06);
}
function triggerSnare(at){
  const noiseBuf=audioCtx.createBuffer(1,audioCtx.sampleRate*0.22,audioCtx.sampleRate);
  const data=noiseBuf.getChannelData(0);
  for(let i=0;i<data.length;i++) data[i]=(Math.random()*2-1);
  const noise=audioCtx.createBufferSource(); noise.buffer=noiseBuf;
  const hp=audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=1200;
  const ng=audioCtx.createGain();
  ng.gain.setValueAtTime(0.0001,at);
  ng.gain.exponentialRampToValueAtTime(0.8,at+0.003);
  ng.gain.exponentialRampToValueAtTime(0.0001,at+0.16);
  noise.connect(hp); hp.connect(ng); ng.connect(master);
  const o=audioCtx.createOscillator(); const g=audioCtx.createGain();
  o.type='triangle'; o.frequency.setValueAtTime(220,at);
  g.gain.setValueAtTime(0.0001,at);
  g.gain.exponentialRampToValueAtTime(0.22,at+0.002);
  g.gain.exponentialRampToValueAtTime(0.0001,at+0.11);
  o.connect(g); g.connect(master);
  noise.start(at); noise.stop(at+0.22);
  o.start(at); o.stop(at+0.13);
}
function triggerClap(at){
  const taps=[0,0.016,0.032,0.048];
  taps.forEach((dt,idx)=>{
    const buf=audioCtx.createBuffer(1,audioCtx.sampleRate*0.08,audioCtx.sampleRate);
    const d=buf.getChannelData(0);
    for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1);
    const s=audioCtx.createBufferSource(); s.buffer=buf;
    const bp=audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1800;
    const g=audioCtx.createGain();
    const t=at+dt;
    g.gain.setValueAtTime(0.0001,t);
    g.gain.exponentialRampToValueAtTime(0.55/(1+idx),t+0.001);
    g.gain.exponentialRampToValueAtTime(0.0001,t+0.06);
    s.connect(bp); bp.connect(g); g.connect(master);
    s.start(t); s.stop(t+0.08);
  });
}
function trigger808(at){
  const o=audioCtx.createOscillator();
  const g=audioCtx.createGain();
  o.type='sine';
  o.frequency.setValueAtTime(80,at);
  o.frequency.exponentialRampToValueAtTime(48,at+0.08);
  g.gain.setValueAtTime(0.0001,at);
  g.gain.exponentialRampToValueAtTime(0.95,at+0.01);
  g.gain.exponentialRampToValueAtTime(0.0001,at+0.8);
  o.connect(g); g.connect(master);
  o.start(at); o.stop(at+0.9);
}
function triggerMetroClick(at){
  const o=audioCtx.createOscillator();
  const g=audioCtx.createGain();
  o.type='square';
  o.frequency.setValueAtTime(1600,at);
  g.gain.setValueAtTime(0.0001,at);
  g.gain.exponentialRampToValueAtTime(0.22,at+0.001);
  g.gain.exponentialRampToValueAtTime(0.0001,at+0.03);
  o.connect(g); g.connect(master);
  o.start(at); o.stop(at+0.04);
}

function triggerPad(padId, atTime=now(), fromPlayback=false){
  ensureAudio();
  if(audioCtx.state!=='running') audioCtx.resume();

  // record performance (latency compensated)
  if(state.isRecording && !fromPlayback){
    const raw = now() - state.takeStart - timing.inputLatency;
    const t = Math.max(0, raw);
    state.takeHits.push({padId, t});
    state.takeLength = Math.max(state.takeLength, t);
    document.getElementById('takeHits').textContent = state.takeHits.length;
  }

  switch(padId){
    case 'KICK': triggerKick(atTime); break;
    case 'SNARE': triggerSnare(atTime); break;
    case 'HAT': triggerHat(atTime); break;
    case 'CLAP': triggerClap(atTime); break;
    case 'BASS808': trigger808(atTime); break;
    case 'METRO': triggerMetroClick(atTime); break;
  }
}

/**********************
 * METRONOME
 **********************/
function startMetronome(){
  ensureAudio();
  if(audioCtx.state!=='running') audioCtx.resume();
  state.metronomeOn=true;
  state.metroNext=now()+0.05;
  if(state.metroTimer) clearInterval(state.metroTimer);
  state.metroTimer=setInterval(()=>{
    const lookahead=0.12;
    while(state.metroNext < now()+lookahead){
      triggerPad('METRO', state.metroNext, true);
      state.metroNext += secondsPerBeat();
    }
  }, 25);
}
function stopMetronome(){
  state.metronomeOn=false;
  if(state.metroTimer) clearInterval(state.metroTimer);
  state.metroTimer=null;
}

/**********************
 * TIMELINE DATA MODEL
 **********************/
const timeline={
  barsVisible:16,
  trackY:70,
  trackH:80,
  headerH:40,
  clips:[], // {id, name, startBar, lengthBars, hits:[]}
  nextId:1
};

function makeClipFromTake(){
  if(!state.takeHits.length) return null;
  const lenBars = Math.max(1, Math.ceil((state.takeLength+0.25)/secondsPerBar()));
  const clip={
    id: 'clip'+(timeline.nextId++),
    name: 'Take '+(timeline.clips.length+1),
    startBar: Math.round(state.playheadBar),
    lengthBars: lenBars,
    hits: structuredClone(state.takeHits)
  };
  timeline.clips.push(clip);
  document.getElementById('clipCount').textContent = timeline.clips.length;
  drawTimeline();
  return clip;
}

/**********************
 * TRANSPORT + PLAYBACK
 **********************/
function setPlayheadBar(bar){
  state.playheadBar = Math.max(1, bar);
  document.getElementById('playheadLabel').textContent = 'bar '+Math.floor(state.playheadBar);
  drawTimeline();
}

function playTimeline(){
  ensureAudio();
  if(audioCtx.state!=='running') audioCtx.resume();
  if(!timeline.clips.length){
    setStatus('no clips');
    return;
  }

  // absolute start time for scheduling
  const base = now() + timing.scheduleAhead;
  state.isPlaying=true;
  state.transportStartCtxTime = base;
  state.transportStartBar = state.playheadBar;
  setStatus('playing');

  // schedule everything in a simple one-shot pass (good for MVP)
  for(const clip of timeline.clips){
    const clipStartSec = (clip.startBar - state.transportStartBar) * secondsPerBar();
    const clipBase = base + clipStartSec;

    // schedule hits
    for(const hit of clip.hits){
      const t = clipBase + hit.t;
      if(t >= base - 0.001){
        triggerPad(hit.padId, t, true);
      }
    }
  }

  // visual playhead updater
  const startPerf=performance.now();
  const startBar=state.transportStartBar;
  function tick(){
    if(!state.isPlaying) return;
    const elapsed = (performance.now()-startPerf)/1000;
    const bar = startBar + (elapsed/secondsPerBar());
    setPlayheadBar(bar);
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
}

function stopAll(){
  state.isRecording=false;
  state.isPlaying=false;
  setStatus('stopped');
}

function setStatus(s){
  document.getElementById('status').innerHTML = `Status: <code>${s}</code>`;
}

/**********************
 * CANVAS TIMELINE UI
 **********************/
const canvas=document.getElementById('timeline');
const ctx=canvas.getContext('2d');

function barsToX(bar){
  const w=canvas.width;
  const leftPad=20;
  const rightPad=20;
  const usable=w-leftPad-rightPad;
  const pxPerBar=(usable/timeline.barsVisible)*state.zoom;
  return leftPad + (bar-1)*pxPerBar;
}

function xToBar(x){
  const leftPad=20;
  const w=canvas.width;
  const usable=w-leftPad-20;
  const pxPerBar=(usable/timeline.barsVisible)*state.zoom;
  return 1 + (x-leftPad)/pxPerBar;
}

function drawTimeline(){
  const w=canvas.width,h=canvas.height;
  ctx.clearRect(0,0,w,h);

  // background
  ctx.fillStyle='#0d0d12';
  ctx.fillRect(0,0,w,h);

  // header
  ctx.fillStyle='rgba(255,255,255,0.06)';
  ctx.fillRect(0,0,w,timeline.headerH);

  // grid bars
  const leftPad=20;
  const rightPad=20;
  const usable=w-leftPad-rightPad;
  const pxPerBar=(usable/timeline.barsVisible)*state.zoom;

  for(let i=0;i<=timeline.barsVisible;i++){
    const x=leftPad + i*pxPerBar;
    const barNum=i+1;

    // major line
    ctx.strokeStyle='rgba(255,255,255,0.18)';
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(x,0);
    ctx.lineTo(x,h);
    ctx.stroke();

    // label
    if(i<timeline.barsVisible){
      ctx.fillStyle='rgba(255,255,255,0.7)';
      ctx.font='12px system-ui, sans-serif';
      ctx.fillText('Bar '+barNum, x+6, 24);
    }

    // beat subdivisions (4 beats per bar)
    if(i<timeline.barsVisible){
      for(let b=1;b<4;b++){
        const bx=x + (b*pxPerBar/4);
        ctx.strokeStyle='rgba(255,255,255,0.08)';
        ctx.beginPath();
        ctx.moveTo(bx, timeline.headerH);
        ctx.lineTo(bx, h);
        ctx.stroke();
      }
    }
  }

  // track lane
  ctx.fillStyle='rgba(255,255,255,0.05)';
  ctx.fillRect(0, timeline.trackY, w, timeline.trackH);
  ctx.fillStyle='rgba(255,255,255,0.7)';
  ctx.font='12px system-ui, sans-serif';
  ctx.fillText('Drums Track', 18, timeline.trackY-8);

  // clips
  for(const clip of timeline.clips){
    const x=barsToX(clip.startBar);
    const x2=barsToX(clip.startBar+clip.lengthBars);
    const cw=x2-x;
    const y=timeline.trackY+16;
    const ch=timeline.trackH-32;

    // body
    ctx.fillStyle='rgba(106,163,255,0.22)';
    ctx.strokeStyle='rgba(106,163,255,0.65)';
    ctx.lineWidth=2;
    roundRect(ctx, x, y, cw, ch, 12, true, true);

    // label
    ctx.fillStyle='rgba(255,255,255,0.92)';
    ctx.font='13px system-ui, sans-serif';
    ctx.fillText(clip.name, x+10, y+22);

    // tiny hit dots (visual hint)
    const baseX=x+10;
    const baseY=y+ch-14;
    ctx.fillStyle='rgba(255,255,255,0.7)';
    const secPerBar=secondsPerBar();
    for(const hit of clip.hits){
      const relBar=hit.t/secPerBar;
      const hx=x + relBar*(cw/clip.lengthBars);
      ctx.fillRect(hx, baseY, 2, 8);
    }

    // handles
    ctx.fillStyle='rgba(255,255,255,0.25)';
    ctx.fillRect(x-2, y, 6, ch);
    ctx.fillRect(x+cw-4, y, 6, ch);
  }

  // playhead
  const phX=barsToX(state.playheadBar);
  ctx.strokeStyle='rgba(255,211,106,0.95)';
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(phX,0);
  ctx.lineTo(phX,h);
  ctx.stroke();
  ctx.fillStyle='rgba(255,211,106,0.95)';
  ctx.fillRect(phX-4, 0, 8, 8);
}

function roundRect(ctx,x,y,w,h,r,fill,stroke){
  const rr=Math.min(r,w/2,h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}

/**********************
 * TIMELINE INTERACTION
 **********************/
let drag=null;
function clipAt(x,y){
  const ty=timeline.trackY+16;
  const th=timeline.trackH-32;
  if(y<ty || y>ty+th) return null;
  for(let i=timeline.clips.length-1;i>=0;i--){
    const c=timeline.clips[i];
    const cx=barsToX(c.startBar);
    const cx2=barsToX(c.startBar+c.lengthBars);
    if(x>=cx && x<=cx2) return {clip:c, cx, cx2};
  }
  return null;
}

canvas.addEventListener('pointerdown',(e)=>{
  const rect=canvas.getBoundingClientRect();
  const x=(e.clientX-rect.left)*(canvas.width/rect.width);
  const y=(e.clientY-rect.top)*(canvas.height/rect.height);

  const hit=clipAt(x,y);
  if(hit){
    const {clip,cx,cx2}=hit;
    const onLeft = Math.abs(x-cx) < 10;
    const onRight = Math.abs(x-cx2) < 10;
    const mode = onLeft?'resizeL':onRight?'resizeR':'move';

    // alt/option = duplicate first
    let workingClip=clip;
    if(e.altKey){
      workingClip=structuredClone(clip);
      workingClip.id='clip'+(timeline.nextId++);
      workingClip.name=clip.name+' copy';
      timeline.clips.push(workingClip);
      document.getElementById('clipCount').textContent = timeline.clips.length;
    }

    drag={
      mode,
      clip:workingClip,
      startX:x,
      startStartBar:workingClip.startBar,
      startLen:workingClip.lengthBars
    };
    canvas.setPointerCapture(e.pointerId);
  } else {
    // set playhead
    setPlayheadBar(xToBar(x));
  }
});

canvas.addEventListener('pointermove',(e)=>{
  if(!drag) return;
  const rect=canvas.getBoundingClientRect();
  const x=(e.clientX-rect.left)*(canvas.width/rect.width);
  const dxBars = xToBar(x) - xToBar(drag.startX);

  if(drag.mode==='move'){
    drag.clip.startBar = Math.max(1, drag.startStartBar + dxBars);
  } else if(drag.mode==='resizeL'){
    const newStart = Math.max(1, drag.startStartBar + dxBars);
    const end = drag.startStartBar + drag.startLen;
    drag.clip.startBar = Math.min(newStart, end-1);
    drag.clip.lengthBars = Math.max(1, end - drag.clip.startBar);
  } else if(drag.mode==='resizeR'){
    drag.clip.lengthBars = Math.max(1, drag.startLen + dxBars);
  }

  drawTimeline();
});

canvas.addEventListener('pointerup',()=>{ drag=null; });
canvas.addEventListener('pointercancel',()=>{ drag=null; });

/**********************
 * UI SETUP
 **********************/
const pads=[
  {id:'KICK',label:'Kick (Q)',key:'KeyQ'},
  {id:'SNARE',label:'Snare (W)',key:'KeyW'},
  {id:'HAT',label:'Hat (E)',key:'KeyE'},
  {id:'CLAP',label:'Clap (A)',key:'KeyA'},
  {id:'BASS808',label:'808 (D)',key:'KeyD'},
  {id:'METRO',label:'(Metro click)',key:null, hidden:true}
];

const padsEl=document.getElementById('pads');
pads.filter(p=>!p.hidden).forEach(p=>{
  const b=document.createElement('button');
  b.className='pad';
  b.textContent=p.label;

  // IMPORTANT: pointerdown = play on press (no release delay)
  b.addEventListener('pointerdown',(ev)=>{
    ev.preventDefault();
    triggerPad(p.id);
  });

  // kill delayed click to avoid double-trigger
  b.addEventListener('click',(ev)=>ev.preventDefault());

  padsEl.appendChild(b);
});

document.addEventListener('keydown',(e)=>{
  const p=pads.find(x=>x.key===e.code);
  if(p) triggerPad(p.id);
});

// buttons

document.getElementById('btnStartAudio').addEventListener('click',()=>{
  ensureAudio(); audioCtx.resume(); setStatus('audio started');
});

document.getElementById('btnMetro').addEventListener('click',()=>{
  ensureAudio();
  if(!state.metronomeOn){startMetronome(); setStatus('metronome ON');}
  else {stopMetronome(); setStatus('metronome OFF');}
});

document.getElementById('btnRecord').addEventListener('click',()=>{
  ensureAudio(); if(audioCtx.state!=='running') audioCtx.resume();
  state.takeHits=[]; state.takeLength=0;
  state.isRecording=true;
  state.takeStart=now();
  document.getElementById('takeHits').textContent='0';
  setStatus('recording take');
});

document.getElementById('btnStop').addEventListener('click',()=>{
  stopAll();
});

document.getElementById('btnPlay').addEventListener('click',()=>{
  playTimeline();
});

document.getElementById('btnAddClip').addEventListener('click',()=>{
  const c=makeClipFromTake();
  if(c) setStatus('clip created');
  else setStatus('no take recorded');
});

document.getElementById('btnClearClips').addEventListener('click',()=>{
  timeline.clips=[];
  document.getElementById('clipCount').textContent='0';
  setStatus('clips cleared');
  drawTimeline();
});

// sliders
const bpmEl=document.getElementById('bpm');
bpmEl.addEventListener('input',(e)=>{
  state.bpm=Number(e.target.value);
  document.getElementById('bpmLabel').textContent=state.bpm;
});

const latEl=document.getElementById('lat');
latEl.addEventListener('input',(e)=>{
  const ms=Number(e.target.value);
  timing.inputLatency=ms/1000;
  document.getElementById('latLabel').textContent=ms;
});

const zoomEl=document.getElementById('zoom');
zoomEl.addEventListener('input',(e)=>{
  state.zoom=Number(e.target.value);
  document.getElementById('zoomLabel').textContent=state.zoom.toFixed(2);
  drawTimeline();
});

// initialize
setPlayheadBar(1);
setStatus('idle');
drawTimeline();
</script>
</body>
</html>
