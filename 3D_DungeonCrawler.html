<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Dungeon RPG (Wave 3)</title>
  <style>
    html,body{height:100%;margin:0;background:#0b0b0b;color:#eee;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto}
    #app{height:100%;width:100%;position:relative;overflow:hidden}
    canvas{display:block}

    .hud{position:absolute;left:12px;top:12px;background:rgba(0,0,0,0.25);backdrop-filter:blur(4px);padding:8px;border-radius:8px;z-index:5}
    .buttons{position:absolute;right:12px;bottom:12px;display:grid;grid-template-columns:repeat(3,56px);gap:8px;z-index:5}
    .btn{width:56px;height:56px;border-radius:12px;background:rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center;font-weight:700;color:#fff;box-shadow:0 6px 12px rgba(0,0,0,0.6);user-select:none}
    .hint{position:absolute;left:12px;bottom:12px;background:rgba(0,0,0,0.28);padding:8px;border-radius:8px;font-size:13px;z-index:5}
    .mini{width:120px;height:120px;border-radius:8px;overflow:hidden}
    .title{font-size:14px;margin-bottom:4px}

    .topRightControls{
      position:absolute;
      right:12px;
      top:12px;
      z-index:12;
      display:flex;
      gap:10px;
      align-items:flex-start;
    }

    .menuBtn{
      width:44px;height:44px;
      border-radius:12px;
      background:rgba(255,255,255,0.07);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:20px;
      font-weight:800;
      box-shadow:0 6px 12px rgba(0,0,0,0.6);
      user-select:none;
    }

    #fade {
      position:absolute; inset:0;
      background:#000;
      opacity:0;
      pointer-events:none;
      z-index:40;
      transition:opacity 180ms ease;
    }
    #fade.on { opacity:1; }

    /* Shared Card Style */
    .field { display:flex; justify-content:space-around; width:100%; margin:10px 0; gap:10px; flex-wrap:wrap; }
    .card { background:#333; border-radius:14px; padding:10px; width:130px; text-align:center; box-shadow:0 0 10px rgba(0,0,0,0.5); transition:transform 0.2s ease; }
    .card.alive:hover { transform:scale(1.05); cursor:pointer; }
    .enemy.card { background:linear-gradient(180deg, #500, #800); }
    .player.card { background:linear-gradient(180deg, #024, #036); }
    .boss.card { background:linear-gradient(180deg, #2a0033, #6a0dad); }
    .item.card { background:linear-gradient(180deg, #2b2b2b, #141414); }
    .dead { opacity:0.3; filter:grayscale(0.8); }
    .turn { outline:3px solid gold; }
    .selected { outline:3px solid #2bd3ff; }

    .hp-bar { width:100%; height:8px; background:#111; border-radius:4px; overflow:hidden; margin-top:7px; }
    .hp-fill { height:100%; width:100%; transition:width 0.3s ease; }

    /* Battle Overlay */
    #battleOverlay{
      position:absolute; inset:0;
      background:linear-gradient(180deg, rgba(0,0,0,0.85), rgba(0,0,0,0.95));
      display:none;
      z-index:50;
      align-items:center;
      justify-content:center;
      padding:18px;
    }
    #battleGame{
      width:100%;
      max-width:720px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:10px;
    }
    #battleTitle{font-size:22px;font-weight:800;letter-spacing:0.5px;margin:0}

    #actions { margin-top:10px; display:flex; gap:10px; flex-wrap:wrap; justify-content:center; }
    #actions button { padding:10px 16px; border:none; border-radius:10px; background:#555; color:#eee; font-size:16px; font-weight:700; }
    #actions button:hover { background:#777; cursor:pointer; }

    #battle-log { margin-top:10px; height:140px; overflow-y:auto; width:100%; background:#151515; padding:10px; border-radius:12px; box-sizing:border-box; font-size:14px; }

    #battleFooter{
      display:flex;
      width:100%;
      justify-content:space-between;
      opacity:0.9;
      font-size:12px;
      margin-top:6px;
    }

    #fx { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:60; }

    /* Party Menu Overlay */
    #partyOverlay{
      position:absolute; inset:0;
      background:linear-gradient(180deg, rgba(0,0,0,0.75), rgba(0,0,0,0.93));
      display:none;
      z-index:45;
      align-items:center;
      justify-content:center;
      padding:18px;
    }

    #partyMenu{
      width:100%;
      max-width:760px;
      display:flex;
      flex-direction:column;
      gap:14px;
      align-items:center;
    }

    #partyHeader{
      width:100%;
      display:flex;
      justify-content:space-between;
      align-items:center;
      opacity:0.95;
      font-size:13px;
    }

    #partyHeader strong{font-size:18px}

    #partyGrid{
      width:100%;
      display:grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap:14px;
    }

    .panel{
      background:rgba(255,255,255,0.06);
      border-radius:16px;
      padding:12px;
      box-shadow:0 0 18px rgba(0,0,0,0.35);
    }

    .panelTitle{
      font-weight:800;
      margin-bottom:8px;
      opacity:0.9;
      display:flex;
      justify-content:space-between;
      align-items:center;
    }

    #partyLog{
      width:100%;
      background:#111;
      border-radius:14px;
      padding:10px;
      min-height:90px;
      box-sizing:border-box;
      font-size:14px;
      opacity:0.95;
      white-space:pre-line;
    }

    #partyFooter{
      width:100%;
      display:flex;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
    }

    .menuActionBtn{
      padding:10px 14px;
      border-radius:12px;
      border:none;
      background:#555;
      color:#eee;
      font-weight:800;
      font-size:14px;
    }
    .menuActionBtn:hover{background:#777;cursor:pointer}
  </style>
</head>
<body>
  <div id="app">
    <div class="hud" id="hud">
      <div class="title">Dungeon RPG (Wave 3)</div>
      <div>Swipe ¬∑ Q/E strafe ¬∑ Hold keys ¬∑ P menu</div>
    </div>

    <div class="topRightControls">
      <div class="menuBtn" id="menuBtn" title="Party Menu (P)">üìú</div>
    </div>

    <div class="buttons" id="buttons" aria-hidden>
      <div class="btn" id="left">‚ü≤</div>
      <div class="btn" id="forward">‚ñ≤</div>
      <div class="btn" id="right">‚ü≥</div>
      <div style="grid-column:2/span1"></div>
      <div class="btn" id="back">‚ñº</div>
      <div style="grid-column:3/span1"></div>
    </div>

    <div class="hint">Tab/P menu ¬∑ Esc close</div>
    <div id="fade"></div>
  </div>

  <canvas id="fx"></canvas>

  <!-- Party Menu -->
  <div id="partyOverlay">
    <div id="partyMenu">
      <div id="partyHeader">
        <strong>Party</strong>
        <div id="partyMeta"></div>
      </div>

      <div id="partyGrid">
        <div class="panel">
          <div class="panelTitle">Party Members</div>
          <div class="field" id="party-field"></div>
        </div>

        <div class="panel">
          <div class="panelTitle">
            <span>Inventory</span>
            <span id="invSmallMeta" style="font-weight:700;opacity:0.8;font-size:12px"></span>
          </div>
          <div class="field" id="inventory-field"></div>
        </div>
      </div>

      <div id="partyLog">Open the menu to manage your run.</div>

      <div id="partyFooter">
        <button class="menuActionBtn" id="closeMenuBtn">Close (Esc)</button>
        <button class="menuActionBtn" id="cancelTargetBtn">Cancel Target</button>
      </div>
    </div>
  </div>

  <!-- Battle -->
  <div id="battleOverlay">
    <div id="battleGame">
      <h1 id="battleTitle">Battle!</h1>
      <div class="field" id="enemy-field"></div>
      <div class="field" id="player-field"></div>
      <div id="actions"></div>
      <div id="battle-log"></div>
      <div id="battleFooter">
        <div id="battleInfoLeft"></div>
        <div id="battleInfoRight"></div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

  <script>
  // ==========================================================
  // RUN STATE (Wave 3: levels + stats)
  // ==========================================================
  const runState = {
    floor: 0,
    gold: 0,
    party: [
      {id:'p1', name:'Alden', level:1, xp:0, xpToNext:30, hp:100, maxHp:100, atk:12, def:5, speed:10, team:'player'},
      {id:'p2', name:'Mireya', level:1, xp:0, xpToNext:30, hp:100, maxHp:100, atk:10, def:6, speed:12, team:'player'},
      {id:'p3', name:'Voss',  level:1, xp:0, xpToNext:30, hp:100, maxHp:100, atk:14, def:4, speed:8,  team:'player'}
    ],
    inventory: { potion: 3, ether: 1 }
  };

  // ==========================================================
  // Helpers
  // ==========================================================
  const MAP_W=15, MAP_H=15;
  const PLAYER_HEIGHT=1;
  const MOVE_DURATION=180, TURN_DURATION=140;
  const TILE_FLOOR=0, TILE_WALL=1, TILE_DOOR=2;

  let battleMode=false, menuMode=false, paused3D=false;
  let minimapWallColorHex='#a36b53', minimapFloorColorHex='#0a0a0a';

  function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

  function blendHexToBlack(hex, amount=0.65){
    const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16);
    const nr=Math.floor(r*(1-amount)), ng=Math.floor(g*(1-amount)), nb=Math.floor(b*(1-amount));
    return '#' + [nr,ng,nb].map(v=>v.toString(16).padStart(2,'0')).join('');
  }

  function isBossFloor(floor){ return floor>0 && floor % 5 === 0; }

  function xpNeeded(level){
    // smooth but meaningful
    return Math.floor(30 + (level-1)*18 + Math.pow(level-1, 1.25)*6);
  }

  function partyAliveCount(){ return runState.party.filter(p=>p.hp>0).length; }

  // ==========================================================
  // Leveling
  // ==========================================================
  function awardXP(amount){
    const logs = [];
    runState.party.forEach(p=>{
      if(p.hp<=0) return; // only living members gain XP (JRPG feel)
      p.xp += amount;
      logs.push(`${p.name} +${amount} XP`);
      while(p.xp >= p.xpToNext){
        p.xp -= p.xpToNext;
        p.level++;
        p.xpToNext = xpNeeded(p.level);

        // stat growth
        const hpGain = 10 + randInt(0,4);
        const atkGain = 2 + (Math.random()<0.35?1:0);
        const defGain = 1 + (Math.random()<0.25?1:0);

        p.maxHp += hpGain;
        p.atk += atkGain;
        p.def += defGain;

        // small heal on level
        p.hp = Math.min(p.maxHp, p.hp + Math.floor(p.maxHp*0.25));

        logs.push(`‚≠ê ${p.name} leveled up! (Lv ${p.level})`);
        logs.push(`+HP ${hpGain}  +ATK ${atkGain}  +DEF ${defGain}`);
      }
    });
    return logs;
  }

  // ==========================================================
  // Loot system
  // ==========================================================
  function rollLootRewards({boss=false}){
    const goldGain = boss
      ? (randInt(30, 55) + runState.floor*4)
      : (randInt(8, 20) + runState.floor*2);

    runState.gold += goldGain;
    const drops = [];

    if(boss){
      // guaranteed meaningful
      runState.inventory.ether = (runState.inventory.ether||0) + 1;
      runState.inventory.potion = (runState.inventory.potion||0) + 2;
      drops.push('‚ú® Ether x1');
      drops.push('üß™ Potion x2');
    } else {
      // JRPG-ish drops
      if(Math.random()<0.35){
        runState.inventory.potion = (runState.inventory.potion||0) + 1;
        drops.push('üß™ Potion x1');
      }
      if(Math.random()<0.12){
        runState.inventory.ether = (runState.inventory.ether||0) + 1;
        drops.push('‚ú® Ether x1');
      }
    }

    return {goldGain,drops};
  }

  // ==========================================================
  // Map generation (rooms + corridors)
  // ==========================================================
  function rectsOverlap(a,b){ return !(a.x2 < b.x1 || a.x1 > b.x2 || a.y2 < b.y1 || a.y1 > b.y2); }
  function carveRoom(map, room){
    for(let y=room.y1;y<=room.y2;y++)
      for(let x=room.x1;x<=room.x2;x++)
        map[y][x]=TILE_FLOOR;
  }
  function carveH(map,x1,x2,y){
    const min=Math.min(x1,x2), max=Math.max(x1,x2);
    for(let x=min;x<=max;x++) map[y][x]=TILE_FLOOR;
  }
  function carveV(map,y1,y2,x){
    const min=Math.min(y1,y2), max=Math.max(y1,y2);
    for(let y=min;y<=max;y++) map[y][x]=TILE_FLOOR;
  }
  function roomCenter(r){ return {x:Math.floor((r.x1+r.x2)/2), y:Math.floor((r.y1+r.y2)/2)}; }
  function connectRooms(map,r1,r2){
    const c1=roomCenter(r1), c2=roomCenter(r2);
    if(Math.random()<0.5){
      carveH(map,c1.x,c2.x,c1.y);
      carveV(map,c1.y,c2.y,c2.x);
    } else {
      carveV(map,c1.y,c2.y,c1.x);
      carveH(map,c1.x,c2.x,c2.y);
    }
  }

  function generateMapRooms(w,h,floor){
    const map = Array.from({length:h},()=>Array(w).fill(TILE_WALL));

    const baseRooms=3;
    const extraRooms=Math.min(10, Math.floor(floor/2));
    const roomCount=baseRooms+extraRooms+randInt(0,2);

    const maxRoomSize=(floor<6)?3:4;
    const minRoomSize=2;

    const rooms=[];
    const tries=180;
    for(let i=0;i<tries && rooms.length<roomCount;i++){
      const rw=randInt(minRoomSize,maxRoomSize);
      const rh=randInt(minRoomSize,maxRoomSize);
      const x1=randInt(1,w-rw-2);
      const y1=randInt(1,h-rh-2);
      const x2=x1+rw-1, y2=y1+rh-1;
      const newRoom={x1,y1,x2,y2};
      const padded={x1:x1-1,y1:y1-1,x2:x2+1,y2:y2+1};

      let ok=true;
      for(const r of rooms){ if(rectsOverlap(padded,r)){ ok=false; break; } }
      if(ok){ rooms.push(newRoom); carveRoom(map,newRoom); }
    }

    for(let i=1;i<rooms.length;i++) connectRooms(map, rooms[i-1], rooms[i]);

    const loopChance = Math.min(0.25, floor*0.02);
    for(let i=0;i<rooms.length;i++){
      if(Math.random()<loopChance && rooms.length>2){
        const a=rooms[i];
        const b=rooms[randInt(0,rooms.length-1)];
        if(a!==b) connectRooms(map,a,b);
      }
    }

    const spawn = rooms.length ? roomCenter(rooms[0]) : {x:Math.floor(w/2), y:Math.floor(h/2)};
    map[spawn.y][spawn.x]=TILE_FLOOR;
    return {map,rooms,spawn};
  }

  // ==========================================================
  // THREE setup
  // ==========================================================
  function randomWallColor(){
    const hue=Math.random();
    const sat=0.35+Math.random()*0.3;
    const light=0.25+Math.random()*0.2;
    return new THREE.Color().setHSL(hue,sat,light);
  }

  const canvasParent=document.getElementById('app');
  const scene=new THREE.Scene();
  scene.background=new THREE.Color(0x070709);

  const renderer=new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  canvasParent.appendChild(renderer.domElement);

  const camera=new THREE.PerspectiveCamera(90, window.innerWidth/window.innerHeight, 0.1, 100);
  scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6));

  const dirLight=new THREE.DirectionalLight(0xfff7d6,0.6);
  dirLight.position.set(5,10,2);
  scene.add(dirLight);

  const playerLight=new THREE.PointLight(0xffeeaa, 1, 6, 2);
  scene.add(playerLight);

  const floorMat=new THREE.MeshStandardMaterial({color:0x1b1b1b, metalness:0.1, roughness:0.9});
  const floorGeo=new THREE.PlaneGeometry(MAP_W, MAP_H);
  const floorMesh=new THREE.Mesh(floorGeo, floorMat);
  floorMesh.rotation.x=-Math.PI/2;
  floorMesh.position.set((MAP_W-1)/2,0,(MAP_H-1)/2);
  scene.add(floorMesh);

  const gridHelper=new THREE.GridHelper(Math.max(MAP_W,MAP_H), Math.max(MAP_W,MAP_H), 0x222222, 0x111111);
  gridHelper.position.copy(floorMesh.position);
  scene.add(gridHelper);

  const walls=new THREE.Group();
  scene.add(walls);

  const doorGeo=new THREE.BoxGeometry(0.72, 1.45, 0.18);
  const doorMat=new THREE.MeshStandardMaterial({
    color:0x2bd3ff, roughness:0.35, metalness:0.2,
    emissive:0x09202a, emissiveIntensity:0.8
  });

  const bossGateMat=new THREE.MeshStandardMaterial({
    color:0xb000ff, roughness:0.2, metalness:0.1,
    emissive:0x2a0033, emissiveIntensity:1.2
  });

  let doorMesh=null;

  const wallGeo=new THREE.BoxGeometry(1,2,1);
  let wallMat=new THREE.MeshStandardMaterial({color: randomWallColor(), roughness:0.85, metalness:0.05});

  // ==========================================================
  // Dungeon state
  // ==========================================================
  let map=null;
  let door={gx:1,gy:1};
  let player={gx:0,gy:0,dir:0};
  let anim=null;

  function cellToWorld(gx,gy){ return {x:gx, y:PLAYER_HEIGHT, z:gy}; }

  function snapCameraToPlayer(){
    const w=cellToWorld(player.gx, player.gy);
    camera.position.set(w.x,w.y,w.z);
    playerLight.position.set(w.x,w.y,w.z);
    camera.rotation.order='YXZ';
    camera.rotation.y = player.dir * -Math.PI/2;
    camera.rotation.x = -0.06;
  }

  function inBounds(x,y){ return x>=0 && y>=0 && x<MAP_W && y<MAP_H; }
  function isWalkable(x,y){ return inBounds(x,y) && map[y][x]!==TILE_WALL; }

  function neighbors(x,y){
    const out=[];
    if(isWalkable(x+1,y)) out.push([x+1,y]);
    if(isWalkable(x-1,y)) out.push([x-1,y]);
    if(isWalkable(x,y+1)) out.push([x,y+1]);
    if(isWalkable(x,y-1)) out.push([x,y-1]);
    return out;
  }

  function computeDistancesFrom(sx,sy){
    const dist=Array.from({length:MAP_H},()=>Array(MAP_W).fill(-1));
    const q=[[sx,sy]];
    dist[sy][sx]=0;
    for(let qi=0;qi<q.length;qi++){
      const [x,y]=q[qi];
      for(const [nx,ny] of neighbors(x,y)){
        if(dist[ny][nx]===-1){
          dist[ny][nx]=dist[y][x]+1;
          q.push([nx,ny]);
        }
      }
    }
    return dist;
  }

  function pickDoorCell(){
    const dist=computeDistancesFrom(player.gx, player.gy);
    let best={gx:player.gx, gy:player.gy, d:-1};
    for(let y=1;y<MAP_H-1;y++){
      for(let x=1;x<MAP_W-1;x++){
        if(map[y][x]===TILE_FLOOR && dist[y][x] > best.d){
          best={gx:x, gy:y, d:dist[y][x]};
        }
      }
    }
    if(best.d<4){
      for(let y=1;y<MAP_H-1;y++){
        for(let x=1;x<MAP_W-1;x++){
          if(map[y][x]===TILE_FLOOR && dist[y][x]>=0) return {gx:x,gy:y};
        }
      }
    }
    return {gx:best.gx, gy:best.gy};
  }

  function clearWalls(){
    while(walls.children.length){
      const c=walls.children.pop();
      c.geometry?.dispose?.();
    }
  }

  function buildDoorMesh(){
    if(doorMesh){ scene.remove(doorMesh); doorMesh=null; }
    const boss = isBossFloor(runState.floor);
    doorMesh = new THREE.Mesh(doorGeo, boss ? bossGateMat : doorMat);
    doorMesh.position.set(door.gx, 0.72, door.gy);
    doorMesh.rotation.y = Math.PI*0.25;
    scene.add(doorMesh);
  }

  function updateHudLine(){
    const hud=document.getElementById('hud');
    let floorLine=document.getElementById('floorLine');
    if(!floorLine){
      floorLine=document.createElement('div');
      floorLine.id='floorLine';
      floorLine.style.marginTop='6px';
      floorLine.style.fontSize='13px';
      floorLine.style.opacity='0.9';
      hud.appendChild(floorLine);
    }
    const boss = isBossFloor(runState.floor);
    floorLine.textContent =
      boss
      ? `Floor: ${runState.floor}  |  BOSS GATE üëÅÔ∏è  |  Gold: ${runState.gold}`
      : `Floor: ${runState.floor}  |  Door üö™  |  Gold: ${runState.gold}`;
  }

  function rebuildDungeon(){
    wallMat = new THREE.MeshStandardMaterial({color: randomWallColor(), roughness:0.85, metalness:0.05});
    minimapWallColorHex = '#' + wallMat.color.getHexString();
    minimapFloorColorHex = blendHexToBlack(minimapWallColorHex, 0.78);

    clearWalls();
    for(let y=0;y<MAP_H;y++){
      for(let x=0;x<MAP_W;x++){
        if(map[y][x]===TILE_WALL){
          const m=new THREE.Mesh(wallGeo, wallMat);
          m.position.set(x,1,y);
          walls.add(m);
        }
      }
    }

    door = pickDoorCell();
    map[door.gy][door.gx]=TILE_DOOR;
    buildDoorMesh();
    updateHudLine();
  }

  function loadNextFloor(){
    runState.floor++;
    const gen=generateMapRooms(MAP_W, MAP_H, runState.floor);
    map=gen.map;
    player.gx=gen.spawn.x;
    player.gy=gen.spawn.y;
    rebuildDungeon();
    snapCameraToPlayer();
  }

  // ==========================================================
  // Encounters + Boss battle trigger
  // ==========================================================
  function encounterChance(){
    if(isBossFloor(runState.floor)) return 0.07; // still some encounters before gate
    const base=0.06;
    const extra=Math.min(0.12, runState.floor*0.01);
    return base+extra;
  }

  function rollEncounter(){
    if(battleMode || menuMode) return false;
    if(map[player.gy][player.gx]===TILE_DOOR) return false;
    return Math.random() < encounterChance();
  }

  // ==========================================================
  // Movement + door handling
  // ==========================================================
  function animateMove(toGx,toGy){
    if(anim || battleMode || menuMode) return;
    if(!isWalkable(toGx,toGy)) return;

    const fromWorld=cellToWorld(player.gx, player.gy);
    const toWorld=cellToWorld(toGx, toGy);
    anim={type:'move', t0:performance.now(), duration:MOVE_DURATION, from:fromWorld, to:toWorld};
    player.gx=toGx; player.gy=toGy;
  }

  function animateTurn(dirDelta){
    if(anim || battleMode || menuMode) return;
    const fromDir=player.dir;
    const toDir=(player.dir + dirDelta + 4)%4;
    anim={type:'turn', t0:performance.now(), duration:TURN_DURATION, from:fromDir, to:toDir};
    player.dir=toDir;
  }

  function stepForward(){
    let nx=player.gx, ny=player.gy;
    if(player.dir===0) ny--;
    if(player.dir===1) nx++;
    if(player.dir===2) ny++;
    if(player.dir===3) nx--;
    animateMove(nx,ny);
  }
  function stepBack(){
    let nx=player.gx, ny=player.gy;
    if(player.dir===0) ny++;
    if(player.dir===1) nx--;
    if(player.dir===2) ny--;
    if(player.dir===3) nx++;
    animateMove(nx,ny);
  }
  function strafeLeft(){
    let nx=player.gx, ny=player.gy;
    if(player.dir===0) nx--;
    if(player.dir===1) ny--;
    if(player.dir===2) nx++;
    if(player.dir===3) ny++;
    animateMove(nx,ny);
  }
  function strafeRight(){
    let nx=player.gx, ny=player.gy;
    if(player.dir===0) nx++;
    if(player.dir===1) ny++;
    if(player.dir===2) nx--;
    if(player.dir===3) ny--;
    animateMove(nx,ny);
  }

  function checkDoor(){
    if(map[player.gy][player.gx] === TILE_DOOR){
      if(isBossFloor(runState.floor)){
        startBattle(true); // boss battle
      } else {
        loadNextFloor();
      }
      return true;
    }
    return false;
  }

  // ==========================================================
  // Render loop
  // ==========================================================
  function render(now){
    now = now || performance.now();
    if(paused3D){ requestAnimationFrame(render); return; }

    if(anim){
      const p=Math.min(1,(now-anim.t0)/anim.duration);
      if(anim.type==='move'){
        const x=anim.from.x+(anim.to.x-anim.from.x)*easeInOutQuad(p);
        const y=anim.from.y+(anim.to.y-anim.from.y)*easeInOutQuad(p);
        const z=anim.from.z+(anim.to.z-anim.from.z)*easeInOutQuad(p);
        camera.position.set(x,y,z);
        playerLight.position.set(x,y,z);

        if(p>=1){
          anim=null;
          if(checkDoor()){ requestAnimationFrame(render); return; }
          if(rollEncounter()){ startBattle(false); requestAnimationFrame(render); return; }
        }
      } else {
        const fromAngle=anim.from * -Math.PI/2;
        const toAngle=anim.to * -Math.PI/2;
        const ang=fromAngle + shortestAngleDiff(fromAngle,toAngle)*easeOutCubic(p);
        camera.rotation.order='YXZ';
        camera.rotation.y=ang;
        camera.rotation.x=-0.06;
        if(p>=1) anim=null;
      }
    } else {
      snapCameraToPlayer();
    }

    renderer.render(scene,camera);
    requestAnimationFrame(render);
  }

  function easeInOutQuad(t){ return t<0.5?2*t*t: -1+(4-2*t)*t; }
  function easeOutCubic(t){ return (--t)*t*t+1; }
  function shortestAngleDiff(a,b){
    let diff=b-a;
    while(diff>Math.PI) diff-=Math.PI*2;
    while(diff<-Math.PI) diff+=Math.PI*2;
    return diff;
  }

  // ==========================================================
  // Minimap
  // ==========================================================
  (function createMini(){
    const mini=document.createElement('canvas');
    mini.width=MAP_W*8;
    mini.height=MAP_H*8;
    mini.className='mini';
    mini.style.position='absolute';
    mini.style.right='12px';
    mini.style.top='68px';
    mini.style.opacity='0.95';
    mini.style.background='rgba(0,0,0,0.28)';
    mini.style.padding='6px';
    document.getElementById('hud').appendChild(mini);

    const ctx=mini.getContext('2d');
    function draw(){
      ctx.clearRect(0,0,mini.width,mini.height);
      for(let y=0;y<MAP_H;y++){
        for(let x=0;x<MAP_W;x++){
          const t=map?.[y]?.[x] ?? TILE_WALL;
          if(t===TILE_WALL) ctx.fillStyle=minimapWallColorHex;
          else if(t===TILE_DOOR) ctx.fillStyle= isBossFloor(runState.floor) ? '#b000ff' : '#2bd3ff';
          else ctx.fillStyle=minimapFloorColorHex;
          ctx.fillRect(x*8,y*8,8,8);
        }
      }

      ctx.fillStyle='#00ffcc';
      ctx.fillRect(player.gx*8+1, player.gy*8+1,6,6);

      ctx.save();
      ctx.translate((player.gx+0.5)*8, (player.gy+0.5)*8);
      ctx.rotate(player.dir * Math.PI/2);
      ctx.beginPath();
      ctx.moveTo(0,-5);
      ctx.lineTo(3,3);
      ctx.lineTo(-3,3);
      ctx.closePath();
      ctx.fill();
      ctx.restore();

      requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);
  })();

  // ==========================================================
  // Input
  // ==========================================================
  let touchStart=null, isTwoFinger=false;

  function onTouchStart(e){
    if(battleMode||menuMode) return;
    isTwoFinger=(e.touches && e.touches.length>1);
    const t=e.touches?e.touches[0]:e;
    touchStart={x:t.clientX,y:t.clientY};
  }
  function onTouchEnd(e){
    if(battleMode||menuMode) return;
    if(!touchStart) return;
    const t=(e.changedTouches && e.changedTouches[0]) || e;
    const dx=t.clientX-touchStart.x;
    const dy=t.clientY-touchStart.y;
    touchStart=null;
    const adx=Math.abs(dx), ady=Math.abs(dy);
    if(Math.max(adx,ady) < 24) return;

    if(adx>ady){
      if(dx>0) animateTurn(1);
      else animateTurn(-1);
    } else {
      if(dy<0){
        if(isTwoFinger){ stepForward(); setTimeout(stepForward, MOVE_DURATION+10); }
        else stepForward();
      } else {
        if(isTwoFinger){ stepBack(); setTimeout(stepBack, MOVE_DURATION+10); }
        else stepBack();
      }
    }
  }

  renderer.domElement.addEventListener('touchstart', onTouchStart, {passive:true});
  renderer.domElement.addEventListener('touchend', onTouchEnd, {passive:true});
  renderer.domElement.addEventListener('mousedown', onTouchStart);
  renderer.domElement.addEventListener('mouseup', onTouchEnd);

  document.getElementById('forward').addEventListener('click', stepForward);
  document.getElementById('back').addEventListener('click', stepBack);
  document.getElementById('left').addEventListener('click', ()=>animateTurn(-1));
  document.getElementById('right').addEventListener('click', ()=>animateTurn(1));

  const keysDown=Object.create(null);
  function setKey(e,isDown){
    keysDown[e.key]=isDown;
    keysDown[e.key.toLowerCase()]=isDown;
    const block=['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ','Spacebar','Tab'];
    if(block.includes(e.key)) e.preventDefault();
  }

  window.addEventListener('keydown',(e)=>{
    const tag=(document.activeElement && document.activeElement.tagName) || '';
    if(tag==='INPUT'||tag==='TEXTAREA') return;
    if(e.key==='p'||e.key==='P'||e.key==='Tab'){ e.preventDefault(); toggleMenu(); return; }
    if(e.key==='Escape'){ if(menuMode) closeMenu(); return; }
    setKey(e,true);
  });
  window.addEventListener('keyup',(e)=>setKey(e,false));

  let lastKeyTick=0;
  function keyboardTick(now){
    if(battleMode||menuMode||anim){ requestAnimationFrame(keyboardTick); return; }
    const down=(...list)=>list.some(k=>keysDown[k]);
    const moveReady=(now-lastKeyTick)>=MOVE_DURATION;
    const turnReady=(now-lastKeyTick)>=TURN_DURATION;

    if(turnReady){
      if(down('a','ArrowLeft')){ animateTurn(-1); lastKeyTick=now; }
      else if(down('d','ArrowRight')){ animateTurn(1); lastKeyTick=now; }
    }
    if(moveReady && !anim){
      const shift=down('Shift');
      if(shift && down('ArrowLeft')){ strafeLeft(); lastKeyTick=now; }
      else if(shift && down('ArrowRight')){ strafeRight(); lastKeyTick=now; }
      else if(down('q')){ strafeLeft(); lastKeyTick=now; }
      else if(down('e')){ strafeRight(); lastKeyTick=now; }
      else if(down('w','ArrowUp')){ stepForward(); lastKeyTick=now; }
      else if(down('s','ArrowDown')){ stepBack(); lastKeyTick=now; }
    }
    requestAnimationFrame(keyboardTick);
  }

  // ==========================================================
  // Party menu
  // ==========================================================
  const partyOverlay=document.getElementById('partyOverlay');
  const partyField=document.getElementById('party-field');
  const invField=document.getElementById('inventory-field');
  const partyLog=document.getElementById('partyLog');
  const partyMeta=document.getElementById('partyMeta');
  const invSmallMeta=document.getElementById('invSmallMeta');

  let selectedItem=null, selectedTargetId=null;

  function partyLogMsg(msg){ partyLog.textContent = msg; }

  function toggleMenu(){
    if(battleMode) return;
    if(menuMode) closeMenu(); else openMenu();
  }
  function openMenu(){
    menuMode=true;
    paused3D=true;
    updatePartyMenu();
    partyOverlay.style.display='flex';
    partyLogMsg('Select an item, then select a party member.');
  }
  function closeMenu(){
    menuMode=false;
    selectedItem=null;
    selectedTargetId=null;
    partyOverlay.style.display='none';
    snapCameraToPlayer();
    paused3D=false;
  }

  function updatePartyMenu(){
    partyMeta.textContent = `Floor ${runState.floor} ¬∑ Gold ${runState.gold} ¬∑ ${isBossFloor(runState.floor)?'BOSS FLOOR':'Dungeon'}`;
    invSmallMeta.textContent = `üß™ ${runState.inventory.potion||0}  ¬∑  ‚ú® ${runState.inventory.ether||0}`;

    partyField.innerHTML='';
    runState.party.forEach(p=>{
      const dead=p.hp<=0;
      const c=document.createElement('div');
      c.className=`player card ${dead?'dead':'alive'} ${p.id===selectedTargetId?'selected':''}`;
      c.innerHTML=`
        <strong>${p.name}</strong>
        <div style="font-size:12px;opacity:0.9;margin-top:4px">Lv ${p.level}</div>
        <div style="font-size:12px;opacity:0.9">HP ${p.hp}/${p.maxHp}</div>
        <div style="font-size:12px;opacity:0.75">ATK ${p.atk} ¬∑ DEF ${p.def} ¬∑ SPD ${p.speed}</div>
        <div class='hp-bar'><div class='hp-fill' style='width:${(p.hp/p.maxHp)*100}%; background:#0f0'></div></div>
        <div style="font-size:12px;opacity:0.85;margin-top:6px">XP ${p.xp}/${p.xpToNext}</div>
      `;
      c.onclick=()=>{
        if(selectedItem) applyItemToTarget(selectedItem, p.id);
        else { selectedTargetId=p.id; partyLogMsg(`${p.name} selected.`); updatePartyMenu(); }
      };
      partyField.appendChild(c);
    });

    invField.innerHTML='';
    invField.appendChild(makeItemCardPotion());
    invField.appendChild(makeItemCardEther());
  }

  function makeItemCardPotion(){
    const inv=runState.inventory;
    const card=document.createElement('div');
    card.className=`item card alive ${selectedItem==='potion'?'selected':''}`;
    card.innerHTML=`
      <strong>üß™ Potion</strong>
      <div style="font-size:12px;opacity:0.9;margin-top:4px">Heal 25 HP</div>
      <div style="margin-top:8px;font-weight:800">x${inv.potion||0}</div>
    `;
    card.onclick=()=>{
      if((inv.potion||0)<=0){ partyLogMsg('No potions left.'); return; }
      selectedItem='potion';
      partyLogMsg('Potion selected. Choose a living party member.');
      updatePartyMenu();
    };
    return card;
  }

  function makeItemCardEther(){
    const inv=runState.inventory;
    const card=document.createElement('div');
    card.className=`item card alive ${selectedItem==='ether'?'selected':''}`;
    card.innerHTML=`
      <strong>‚ú® Ether</strong>
      <div style="font-size:12px;opacity:0.9;margin-top:4px">Revive ally (30 HP)</div>
      <div style="margin-top:8px;font-weight:800">x${inv.ether||0}</div>
    `;
    card.onclick=()=>{
      if((inv.ether||0)<=0){ partyLogMsg('No ether left.'); return; }
      selectedItem='ether';
      partyLogMsg('Ether selected. Choose a fallen ally.');
      updatePartyMenu();
    };
    return card;
  }

  function applyItemToTarget(itemId,targetId){
    const target=runState.party.find(p=>p.id===targetId);
    if(!target){ partyLogMsg('Invalid target.'); return; }

    if(itemId==='potion'){
      if((runState.inventory.potion||0)<=0){ partyLogMsg('No potions left.'); return; }
      if(target.hp<=0){ partyLogMsg('Potion can‚Äôt be used on fallen allies. Use Ether.'); return; }
      runState.inventory.potion--;
      const heal=25;
      target.hp=Math.min(target.maxHp,target.hp+heal);
      partyLogMsg(`Used Potion on ${target.name}. +${heal} HP.`);
    }

    if(itemId==='ether'){
      if((runState.inventory.ether||0)<=0){ partyLogMsg('No ether left.'); return; }
      if(target.hp>0){ partyLogMsg('Ether revives fallen allies only.'); return; }
      runState.inventory.ether--;
      target.hp=Math.min(target.maxHp,30);
      partyLogMsg(`‚ú® Revived ${target.name} (30 HP).`);
    }

    selectedItem=null;
    selectedTargetId=targetId;
    updateHudLine();
    updatePartyMenu();
  }

  document.getElementById('menuBtn').addEventListener('click', toggleMenu);
  document.getElementById('closeMenuBtn').addEventListener('click', closeMenu);
  document.getElementById('cancelTargetBtn').addEventListener('click', ()=>{
    selectedItem=null; selectedTargetId=null;
    partyLogMsg('Selection cleared.');
    updatePartyMenu();
  });

  // ==========================================================
  // Battle system (Wave 3: stats + boss) ‚Äì maintains card combat flow :contentReference[oaicite:1]{index=1}
  // ==========================================================
  let enemies=[], allUnits=[], turnQueue=[], currentUnit=null;
  let currentBattleIsBoss=false;

  const overlay=document.getElementById('battleOverlay');
  const fade=document.getElementById('fade');

  function fadeOn(){ fade.classList.add('on'); }
  function fadeOff(){ fade.classList.remove('on'); }

  function logBattle(text){
    const logDiv=document.getElementById('battle-log');
    logDiv.innerHTML += text + '<br>';
    logDiv.scrollTop = logDiv.scrollHeight;
  }

  function setBattleHud(){
    document.getElementById('battleInfoLeft').textContent =
      currentBattleIsBoss ? `Floor ${runState.floor} ¬∑ BOSS FIGHT` : `Floor ${runState.floor} ¬∑ Encounter`;
    document.getElementById('battleInfoRight').textContent =
      currentBattleIsBoss ? `Defeat the boss to proceed` : `Defeat all enemies`;
  }

  function enemyNamePool(){ return ['Goblin','Slime','Bat','Wisp','Skeleton','Cultist']; }

  function makeEnemyUnit(name){
    // normal enemy scaling
    const level = Math.max(1, Math.floor(runState.floor/2));
    const hpBase = 70 + runState.floor*10;
    const atkBase = 10 + runState.floor*1.6;
    const defBase = 3 + runState.floor*0.7;

    const hp = randInt(hpBase, hpBase+25);
    const speed = randInt(7,12) + Math.floor(runState.floor/3);

    return {
      id:'e'+Math.random().toString(16).slice(2),
      name,
      level,
      hp, maxHp:hp,
      atk: Math.floor(atkBase + randInt(-2,3)),
      def: Math.floor(defBase + randInt(-1,2)),
      speed,
      team:'enemy',
      boss:false
    };
  }

  function makeBossUnit(){
    const level = Math.max(3, Math.floor(runState.floor/1.8));
    const hp = 260 + runState.floor*35;
    const speed = 12 + Math.floor(runState.floor/5);
    return {
      id:'boss'+Math.random().toString(16).slice(2),
      name:`Gatekeeper of Floor ${runState.floor}`,
      level,
      hp, maxHp:hp,
      atk: 20 + Math.floor(runState.floor*2.5),
      def: 8 + Math.floor(runState.floor*1.2),
      speed,
      team:'enemy',
      boss:true
    };
  }

  function generateEncounter(isBoss){
    currentBattleIsBoss = isBoss;

    if(isBoss){
      enemies = [ makeBossUnit() ];
    } else {
      const count = Math.min(3, 1 + Math.floor(runState.floor/3) + (Math.random()<0.35 ? 1 : 0));
      const roster = enemyNamePool();
      enemies = Array.from({length:count}, (_,i)=> makeEnemyUnit(`${roster[randInt(0, roster.length-1)]} ${i+1}`));
    }

    allUnits = [...runState.party, ...enemies];
  }

  function updateBattleStatus(){
    const playerField=document.getElementById('player-field');
    const enemyField=document.getElementById('enemy-field');
    playerField.innerHTML=''; enemyField.innerHTML='';

    runState.party.forEach(p => playerField.appendChild(makeBattleCard(p)));
    enemies.forEach(e => enemyField.appendChild(makeBattleCard(e)));
  }

  function makeBattleCard(unit){
    const dead=unit.hp<=0;
    const card=document.createElement('div');

    const cls = unit.team==='player'
      ? `player card ${dead?'dead':'alive'}`
      : `${unit.boss?'boss':'enemy'} card ${dead?'dead':'alive'}`;

    card.className = `${cls} ${currentUnit===unit?'turn':''}`;

    const color = unit.team==='player'?'#0f0': (unit.boss ? '#b000ff' : '#f00');

    const extraStats = unit.team==='player'
      ? `<div style="font-size:12px;opacity:0.75;margin-top:4px">Lv ${unit.level} ¬∑ ATK ${unit.atk} ¬∑ DEF ${unit.def}</div>`
      : `<div style="font-size:12px;opacity:0.75;margin-top:4px">Lv ${unit.level}${unit.boss?' ¬∑ BOSS':''}</div>`;

    card.innerHTML = `
      <strong>${unit.name}</strong>
      ${extraStats}
      <div class='hp-bar'><div class='hp-fill' style='width:${(unit.hp/unit.maxHp)*100}%; background:${color}'></div></div>
    `;

    if(currentUnit && currentUnit.team==='player' && unit.team==='enemy' && unit.hp>0){
      card.onclick = ()=>playerAttack(unit);
    }
    return card;
  }

  function setupQueue(){ turnQueue=[...allUnits].sort((a,b)=>b.speed-a.speed); }

  function checkGameOver(){
    if(runState.party.every(p=>p.hp<=0)){ logBattle('üíÄ Party defeated...'); return 'lose'; }
    if(enemies.every(e=>e.hp<=0)){ logBattle(currentBattleIsBoss ? 'üëÅÔ∏è Boss defeated!' : 'üéâ Victory!'); return 'win'; }
    return null;
  }

  function nextTurn(){
    const res=checkGameOver();
    if(res){ endBattle(res==='win'); return; }

    currentUnit = turnQueue.shift();
    if(currentUnit.hp<=0){ nextTurn(); return; }
    turnQueue.push(currentUnit);

    updateBattleStatus();
    if(currentUnit.team==='player') showPlayerActions();
    else enemyAction();
  }

  function showPlayerActions(){
    const actionsDiv=document.getElementById('actions');
    actionsDiv.innerHTML='';
    ['Attack','Heal'].forEach(act=>{
      const btn=document.createElement('button');
      btn.innerText=act;
      btn.onclick=()=> act==='Attack' ? logBattle('Choose an enemy target!') : playerHeal();
      actionsDiv.appendChild(btn);
    });
  }

  function calcDamage(attacker, target){
    const roll = randInt(0,6);
    const raw = (attacker.atk + roll) - target.def;
    return Math.max(1, raw);
  }

  function playerAttack(target){
    const dmg = calcDamage(currentUnit, target);
    target.hp = Math.max(0, target.hp - dmg);
    logBattle(`${currentUnit.name} strikes ${target.name} for ${dmg} damage!`);
    playSlashFX();
    endTurn();
  }

  function playerHeal(){
    const base = 10 + Math.floor(currentUnit.level*2);
    const healAmount = randInt(base, base+10);
    currentUnit.hp = Math.min(currentUnit.maxHp, currentUnit.hp + healAmount);
    logBattle(`${currentUnit.name} heals for ${healAmount} HP!`);
    playHealFX();
    endTurn();
  }

  function enemyAction(){
    const alive=runState.party.filter(p=>p.hp>0);
    const target=alive[randInt(0, alive.length-1)];

    // boss special attack chance
    let dmg = calcDamage(currentUnit, target);
    if(currentUnit.boss && Math.random() < 0.25){
      dmg = Math.floor(dmg * 1.7);
      logBattle(`üëÅÔ∏è ${currentUnit.name} uses a special attack!`);
    }

    target.hp = Math.max(0, target.hp - dmg);
    logBattle(`${currentUnit.name} hits ${target.name} for ${dmg} damage!`);
    playSlashFX();
    endTurn();
  }

  function endTurn(){
    document.getElementById('actions').innerHTML='';
    updateBattleStatus();
    setTimeout(nextTurn, 700);
  }

  function startBattle(isBoss){
    if(menuMode) closeMenu();

    battleMode=true;
    currentBattleIsBoss = isBoss;

    fadeOn();
    setTimeout(()=>{
      paused3D=true;
      overlay.style.display='flex';

      document.getElementById('battle-log').innerHTML='';
      document.getElementById('actions').innerHTML='';

      generateEncounter(isBoss);
      setupQueue();
      setBattleHud();
      updateBattleStatus();

      logBattle(isBoss ? 'üëÅÔ∏è Boss battle!' : '‚öîÔ∏è Encounter!');
      fadeOff();

      nextTurn();
    }, 160);
  }

  function endBattle(victory){
    setTimeout(()=>{
      fadeOn();
      setTimeout(()=>{
        if(victory){
          // XP
          const baseXP = currentBattleIsBoss
            ? (40 + runState.floor*6)
            : (12 + runState.floor*3 + enemies.length*4);

          const xpLogs = awardXP(baseXP);

          // Loot
          const rewards = rollLootRewards({boss:currentBattleIsBoss});

          logBattle(`ü™ô +${rewards.goldGain} gold`);
          rewards.drops.forEach(d=>logBattle(`üéÅ ${d}`));
          xpLogs.forEach(x=>logBattle(x));

          // also menu log
          let msg = `Rewards:\nü™ô +${rewards.goldGain} gold\n`;
          if(rewards.drops.length) msg += rewards.drops.join('\n') + '\n';
          msg += `\nXP:\n` + xpLogs.join('\n');
          partyLogMsg(msg);
        }

        overlay.style.display='none';
        battleMode=false;

        if(!victory){
          // soft fail
          runState.floor = Math.max(0, runState.floor-1);
          loadNextFloor();
          partyLogMsg('Defeat penalty: pushed back a floor.');
        } else {
          // if boss was defeated: proceed to next floor
          if(currentBattleIsBoss){
            // small heal bonus on boss win
            runState.party.forEach(p=>{
              if(p.hp>0) p.hp = Math.min(p.maxHp, p.hp + Math.floor(p.maxHp*0.35));
            });
            loadNextFloor();
          }
        }

        updateHudLine();
        updatePartyMenu();
        snapCameraToPlayer();
        paused3D=false;
        fadeOff();
      },180);
    },650);
  }

  // ==========================================================
  // FX Canvas (based on your system style) :contentReference[oaicite:2]{index=2}
  // ==========================================================
  const fxCanvas=document.getElementById('fx');
  const fxCtx=fxCanvas.getContext('2d');
  resizeFx();
  window.addEventListener('resize', resizeFx);
  function resizeFx(){ fxCanvas.width=window.innerWidth; fxCanvas.height=window.innerHeight; }

  function playSlashFX(){ drawFX('#f00'); }
  function playHealFX(){ drawFX('#0f0'); }

  function drawFX(color){
    let alpha=1;
    function anim(){
      fxCtx.clearRect(0,0,fxCanvas.width,fxCanvas.height);
      fxCtx.globalAlpha=alpha;
      fxCtx.strokeStyle=color;
      fxCtx.lineWidth=5;
      fxCtx.beginPath();
      fxCtx.moveTo(Math.random()*fxCanvas.width, Math.random()*fxCanvas.height);
      fxCtx.lineTo(Math.random()*fxCanvas.width, Math.random()*fxCanvas.height);
      fxCtx.stroke();
      fxCtx.globalAlpha=1;
      alpha-=0.1;
      if(alpha>0) requestAnimationFrame(anim);
      else fxCtx.clearRect(0,0,fxCanvas.width,fxCanvas.height);
    }
    anim();
  }

  // ==========================================================
  // Boot
  // ==========================================================
  loadNextFloor();
  snapCameraToPlayer();
  requestAnimationFrame(render);
  requestAnimationFrame(keyboardTick);
  </script>
</body>
</html>
