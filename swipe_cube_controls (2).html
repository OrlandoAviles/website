<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Swipe Cube Motion Follow with Field</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';

    // Scene, camera, renderer
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 10; // zoomed out

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Cube character
    const geometry = new THREE.BoxGeometry();
    const material = new THREE.MeshNormalMaterial();
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);

    // Field boundaries
    const field = { width: 50, height: 50 };

    // Add random colored cubes for spatial context
    const smallCubes = [];
    for (let i = 0; i < 100; i++) {
      const size = Math.random() * 0.3 + 0.2;
      const geom = new THREE.BoxGeometry(size, size, size);
      const mat = new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff });
      const c = new THREE.Mesh(geom, mat);
      c.position.x = (Math.random() - 0.5) * field.width;
      c.position.y = (Math.random() - 0.5) * field.height;
      c.position.z = (Math.random() - 0.5) * 2;
      scene.add(c);
      smallCubes.push(c);
    }

    // Swipe-follow variables
    let targetPosition = { x: 0, y: 0 };
    let isSwiping = false;

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function animate() {
      requestAnimationFrame(animate);

      if (isSwiping) {
        // Smooth follow toward swipe position
        cube.position.x += (targetPosition.x - cube.position.x) * 0.2;
        cube.position.y += (targetPosition.y - cube.position.y) * 0.2;

        // Clamp to field boundaries
        cube.position.x = clamp(cube.position.x, -field.width/2, field.width/2);
        cube.position.y = clamp(cube.position.y, -field.height/2, field.height/2);

        // Stop when very close
        if (Math.abs(targetPosition.x - cube.position.x) < 0.01 && Math.abs(targetPosition.y - cube.position.y) < 0.01) {
          isSwiping = false;
        }
      }

      // Camera follows cube smoothly
      camera.position.x += (cube.position.x - camera.position.x) * 0.05;
      camera.position.y += (cube.position.y - camera.position.y) * 0.05;
      camera.lookAt(cube.position);

      renderer.render(scene, camera);
    }
    animate();

    // Touch handling for swipe-follow
    let startX = 0, startY = 0;

    window.addEventListener("touchstart", e => {
      const touch = e.touches[0];
      startX = touch.clientX;
      startY = touch.clientY;
    });

    window.addEventListener("touchmove", e => {
      const touch = e.touches[0];
      const dx = (touch.clientX - startX) / window.innerWidth * field.width;
      const dy = -(touch.clientY - startY) / window.innerHeight * field.height;
      targetPosition.x = clamp(cube.position.x + dx, -field.width/2, field.width/2);
      targetPosition.y = clamp(cube.position.y + dy, -field.height/2, field.height/2);
      isSwiping = true;
    });

    // Resize handling
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
